<!DOCTYPE html><html class="h-100"><head><title>pageTitle: not defined</title><link rel="stylesheet" href="/stylesheets/style.css"><link rel="stylesheet" href="/bootstrap/bootstrap.min.css"><script src="/bootstrap/bootstrap.bundle.min.js"> </script><script>function getDate() {
  var date = new Date().toLocaleString();
  let arr = date.split(",");
  date = arr[0] + "<br>" + arr[1];

  document.getElementById("timedisplay").innerHTML = date.toLocaleString();
}
setInterval(getDate, 0);
</script><script>var pageProps={};</script></head><body class="h-100"><div class="container-fluid h-100 d-flex flex-column"> <div class="row"><div class="col-3"><img src="/img/logo_bortek.png" alt="Бортек" id="logo"></div><div class="col my-auto mx-auto "><div class="h2 " id="pageTitle">pageTitle: not defined</div></div><div class="col-1 my-auto mx-auto "><div class="h5" id="timedisplay"></div></div><hr></div><div class="row h-100"><div class="col"><div class="h-100" id="pageBody"><p>--------------------- debugging info manager = -----------------------------<pre>{&quot;id&quot;:&quot;TasksManager&quot;,&quot;ln&quot;:&quot;ClassTasksManager(TasksManager)::&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;Створення програми&quot;,&quot;en&quot;:&quot;Program creating&quot;,&quot;ru&quot;:&quot;Создание программы&quot;},&quot;type&quot;:&quot;select&quot;,&quot;value&quot;:&quot;empty&quot;,&quot;comment&quot;:{&quot;ua&quot;:&quot;Після редагування програми натисніть кнопку [Застосувати]&quot;,&quot;en&quot;:&quot;After program creation, push [Accept] button&quot;,&quot;ru&quot;:&quot;После редактирования програмы, нажмите кнопку [Применить] &quot;},&quot;editable&quot;:true,&quot;regs&quot;:{},&quot;reg&quot;:{&quot;id&quot;:&quot;taskType&quot;,&quot;ln&quot;:&quot;ClassReg_select(taskType)::&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;Тип кроку&quot;,&quot;en&quot;:&quot;Select type of step&quot;,&quot;ru&quot;:&quot;Тип шага&quot;},&quot;type&quot;:&quot;select&quot;,&quot;comment&quot;:{&quot;ua&quot;:&quot;Доступні типи&quot;,&quot;en&quot;:&quot;Avaliable types&quot;,&quot;ru&quot;:&quot;Доступные типы&quot;},&quot;editable&quot;:true,&quot;regs&quot;:{&quot;description&quot;:{&quot;id&quot;:&quot;description&quot;,&quot;ln&quot;:&quot;ClassReg_regsList(description)::&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;Програма &quot;,&quot;en&quot;:&quot;Program&quot;,&quot;ru&quot;:&quot;Программа&quot;},&quot;type&quot;:&quot;regsList&quot;,&quot;comment&quot;:{&quot;ua&quot;:&quot;&quot;,&quot;en&quot;:&quot;&quot;,&quot;ru&quot;:&quot;&quot;},&quot;editable&quot;:false,&quot;regs&quot;:{&quot;name&quot;:{&quot;id&quot;:&quot;name&quot;,&quot;ln&quot;:&quot;tasks.description.fileName::&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;Назва програми&quot;,&quot;en&quot;:&quot;Program name&quot;,&quot;ru&quot;:&quot;Наименование программы&quot;},&quot;type&quot;:&quot;text&quot;,&quot;value&quot;:&quot;empty&quot;,&quot;comment&quot;:{&quot;ua&quot;:&quot;Коротка назва програми (3..20 символів)&quot;,&quot;en&quot;:&quot;Short name of the program (3..2 characters)&quot;,&quot;ru&quot;:&quot;Короткое имя программы (3..20 символов)&quot;},&quot;editable&quot;:true}}},&quot;ClassTask_Heating&quot;:{&quot;id&quot;:&quot;ClassTask_Heating&quot;,&quot;ln&quot;:&quot;ClassTaskThermal()::&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;Нагрівання&quot;,&quot;en&quot;:&quot;Heating&quot;,&quot;ru&quot;:&quot;Нагревание&quot;},&quot;type&quot;:&quot;regsList&quot;,&quot;comment&quot;:{&quot;ua&quot;:&quot;Немає опису&quot;,&quot;en&quot;:&quot;Note not defined&quot;,&quot;ru&quot;:&quot;Описания нет&quot;},&quot;editable&quot;:true,&quot;regs&quot;:{&quot;tT&quot;:{&quot;id&quot;:&quot;tT&quot;,&quot;ln&quot;:&quot;ClassReg_number(tT)::&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;T,°C&quot;,&quot;en&quot;:&quot;T,°C&quot;,&quot;ru&quot;:&quot;T,°C&quot;},&quot;type&quot;:&quot;number&quot;,&quot;value&quot;:0,&quot;comment&quot;:{&quot;ua&quot;:&quot;Цільова температура&quot;,&quot;en&quot;:&quot;Task temperature&quot;,&quot;ru&quot;:&quot;Целевая температура&quot;},&quot;editable&quot;:true,&quot;min&quot;:0,&quot;max&quot;:150},&quot;errTmin&quot;:{&quot;id&quot;:&quot;errTmin&quot;,&quot;ln&quot;:&quot;ClassReg_number(errTmin)::&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;errTmin,°C&quot;,&quot;en&quot;:&quot;errTmin,°C&quot;,&quot;ru&quot;:&quot;errTmin,°C&quot;},&quot;type&quot;:&quot;number&quot;,&quot;value&quot;:0,&quot;comment&quot;:{&quot;ua&quot;:&quot;Макс. відх. вниз (0=вимкн)&quot;,&quot;en&quot;:&quot;Limit of low temperature (0=disable)&quot;,&quot;ru&quot;:&quot;Макс. откл. вниз (0=выкл)&quot;},&quot;editable&quot;:true,&quot;min&quot;:-100,&quot;max&quot;:0},&quot;errTmax&quot;:{&quot;id&quot;:&quot;errTmax&quot;,&quot;ln&quot;:&quot;ClassReg_number(errTmax)::&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;errTmax,°C&quot;,&quot;en&quot;:&quot;errTmax,°C&quot;,&quot;ru&quot;:&quot;errTmax,°C&quot;},&quot;type&quot;:&quot;number&quot;,&quot;value&quot;:0,&quot;comment&quot;:{&quot;ua&quot;:&quot;Макс. відх. вверх (0=вимкн)&quot;,&quot;en&quot;:&quot;Limit of high temperature (0=disable)&quot;,&quot;ru&quot;:&quot;Макс. откл. вверх (0=выкл)&quot;},&quot;editable&quot;:true,&quot;min&quot;:0,&quot;max&quot;:100},&quot;regMode&quot;:{&quot;id&quot;:&quot;regMode&quot;,&quot;ln&quot;:&quot;ClassReg_select(regMode)::&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;Регулювання&quot;,&quot;en&quot;:&quot;Regulation&quot;,&quot;ru&quot;:&quot;Регулирование&quot;},&quot;type&quot;:&quot;select&quot;,&quot;value&quot;:&quot;pid&quot;,&quot;comment&quot;:{&quot;ua&quot;:&quot;Закон регулювання&quot;,&quot;en&quot;:&quot;Control type&quot;,&quot;ru&quot;:&quot;Закон регулирования&quot;},&quot;editable&quot;:true,&quot;regs&quot;:{&quot;pos&quot;:{&quot;id&quot;:&quot;pos&quot;,&quot;ln&quot;:&quot;ClassReg_regsList(pos)::&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;Позиційний&quot;,&quot;en&quot;:&quot;Positional&quot;,&quot;ru&quot;:&quot;Позиционный&quot;},&quot;type&quot;:&quot;regsList&quot;,&quot;comment&quot;:{&quot;ua&quot;:&quot;Позиційний закон регулювання&quot;,&quot;en&quot;:&quot;Positional regulation&quot;,&quot;ru&quot;:&quot;Позиционный закон регуллирования&quot;},&quot;editable&quot;:true,&quot;regs&quot;:{&quot;o&quot;:{&quot;id&quot;:&quot;o&quot;,&quot;ln&quot;:&quot;ClassReg_number(o)::&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;Неузгодження&quot;,&quot;en&quot;:&quot;Difference&quot;,&quot;ru&quot;:&quot;Рассогласование&quot;},&quot;type&quot;:&quot;number&quot;,&quot;value&quot;:-2,&quot;comment&quot;:{&quot;ua&quot;:&quot;Неузгодження температур,°С&quot;,&quot;en&quot;:&quot;Temperature difference,°С&quot;,&quot;ru&quot;:&quot;Рассогласование температур,°С&quot;},&quot;editable&quot;:true,&quot;min&quot;:-20,&quot;max&quot;:0}}},&quot;pid&quot;:{&quot;id&quot;:&quot;pid&quot;,&quot;ln&quot;:&quot;ClassReg_regsList(pid)::&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;ПІД&quot;,&quot;en&quot;:&quot;PID&quot;,&quot;ru&quot;:&quot;ПИД&quot;},&quot;type&quot;:&quot;regsList&quot;,&quot;comment&quot;:{&quot;ua&quot;:&quot;ПІД закон регулювання&quot;,&quot;en&quot;:&quot;PID regulation&quot;,&quot;ru&quot;:&quot;ПИД закон регуллирования&quot;},&quot;editable&quot;:true,&quot;regs&quot;:{&quot;o&quot;:{&quot;id&quot;:&quot;o&quot;,&quot;ln&quot;:&quot;ClassReg_number(o)::&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;П&quot;,&quot;en&quot;:&quot;P&quot;,&quot;ru&quot;:&quot;П&quot;},&quot;type&quot;:&quot;number&quot;,&quot;value&quot;:5,&quot;comment&quot;:{&quot;ua&quot;:&quot;Пропорційна складова&quot;,&quot;en&quot;:&quot;Proportional gain&quot;,&quot;ru&quot;:&quot;Пропорциональная составляющая&quot;},&quot;editable&quot;:true,&quot;min&quot;:0,&quot;max&quot;:100},&quot;ti&quot;:{&quot;id&quot;:&quot;ti&quot;,&quot;ln&quot;:&quot;ClassReg_number(ti)::&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;І&quot;,&quot;en&quot;:&quot;I&quot;,&quot;ru&quot;:&quot;И&quot;},&quot;type&quot;:&quot;number&quot;,&quot;value&quot;:5,&quot;comment&quot;:{&quot;ua&quot;:&quot;Інтегральна складова&quot;,&quot;en&quot;:&quot;Integral gain&quot;,&quot;ru&quot;:&quot;Интегральная составляющая&quot;},&quot;editable&quot;:true,&quot;min&quot;:0,&quot;max&quot;:100},&quot;td&quot;:{&quot;id&quot;:&quot;td&quot;,&quot;ln&quot;:&quot;ClassReg_number(td)::&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;Д&quot;,&quot;en&quot;:&quot;D&quot;,&quot;ru&quot;:&quot;Д&quot;},&quot;type&quot;:&quot;number&quot;,&quot;value&quot;:5,&quot;comment&quot;:{&quot;ua&quot;:&quot;Диференційна складова&quot;,&quot;en&quot;:&quot;Differencial gain&quot;,&quot;ru&quot;:&quot;Диферинциальная составляющая&quot;},&quot;editable&quot;:true,&quot;min&quot;:0,&quot;max&quot;:100}}}}},&quot;wT&quot;:{&quot;id&quot;:&quot;wT&quot;,&quot;ln&quot;:&quot;ClassReg_number(wT)::&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;wT,°C&quot;,&quot;en&quot;:&quot;wT,°C&quot;,&quot;ru&quot;:&quot;wT,°C&quot;},&quot;type&quot;:&quot;number&quot;,&quot;value&quot;:0,&quot;comment&quot;:{&quot;ua&quot;:&quot;Початок ПІД рег. (=0 вимкн.)&quot;,&quot;en&quot;:&quot;Start PID regulation (=0 off)&quot;,&quot;ru&quot;:&quot;Начало ПИД рег. (=0-выкл.)&quot;},&quot;editable&quot;:true,&quot;min&quot;:-200,&quot;max&quot;:0},&quot;H&quot;:{&quot;id&quot;:&quot;H&quot;,&quot;ln&quot;:&quot;ClassReg_timer(H)::&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;Нагрівання&quot;,&quot;en&quot;:&quot;Heating&quot;,&quot;ru&quot;:&quot;Нагревание&quot;},&quot;type&quot;:&quot;timer&quot;,&quot;value&quot;:0,&quot;comment&quot;:{&quot;ua&quot;:&quot;Час нагрівання (=0 - макс. швидко)&quot;,&quot;en&quot;:&quot;Heating time (=0 quick)&quot;,&quot;ru&quot;:&quot;Время нагревания (=0 макс. быстро)&quot;},&quot;editable&quot;:true,&quot;min&quot;:0,&quot;max&quot;:1439}}}}},&quot;list&quot;:[{&quot;id&quot;:&quot;description&quot;,&quot;name&quot;:&quot;prg01&quot;,&quot;created&quot;:&quot;2023-05-03T11:04:49.715Z&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;Опис програми&quot;,&quot;en&quot;:&quot;Program description&quot;,&quot;ru&quot;:&quot;Описание программы&quot;},&quot;note&quot;:&quot;Короткий опис програми&quot;},{&quot;id&quot;:&quot;ClassTask_Heating&quot;,&quot;tT&quot;:80,&quot;errTmin&quot;:-15,&quot;errTmax&quot;:15,&quot;regMode&quot;:&quot;pid&quot;,&quot;o&quot;:10,&quot;i&quot;:10,&quot;d&quot;:10},{&quot;id&quot;:&quot;ClassTask_Heating&quot;,&quot;tT&quot;:120,&quot;errTmin&quot;:-10,&quot;errTmax&quot;:10,&quot;regMode&quot;:&quot;pid&quot;,&quot;o&quot;:20,&quot;i&quot;:20,&quot;d&quot;:20},{&quot;id&quot;:&quot;TaskNitriding&quot;,&quot;kN&quot;:1.2,&quot;regMode&quot;:&quot;pid&quot;,&quot;o&quot;:10,&quot;i&quot;:10,&quot;d&quot;:10}]}  </pre></p><p>--------------------- debugging info -----------------------------</p><div class="row"><div class="col"><h3>Завдання</h3></div></div><div class="row"><div class="col" id="tasksContainer"></div></div><script>const lang= 'ua'; 
const tasks={};
tasks.header = JSON.parse(  '{"ua":"Створення програми","en":"Program creating","ru":"Создание программы"}' );
tasks.comment = JSON.parse(  '{"ua":"Після редагування програми натисніть кнопку [Застосувати]","en":"After program creation, push [Accept] button","ru":"После редактирования програмы, нажмите кнопку [Применить] "}' );
tasks.id=JSON.parse(  '"TasksManager"' );
tasks.reg = JSON.parse(  '{"id":"taskType","ln":"ClassReg_select(taskType)::","header":{"ua":"Тип кроку","en":"Select type of step","ru":"Тип шага"},"type":"select","comment":{"ua":"Доступні типи","en":"Avaliable types","ru":"Доступные типы"},"editable":true,"regs":{"description":{"id":"description","ln":"ClassReg_regsList(description)::","header":{"ua":"Програма ","en":"Program","ru":"Программа"},"type":"regsList","comment":{"ua":"","en":"","ru":""},"editable":false,"regs":{"name":{"id":"name","ln":"tasks.description.fileName::","header":{"ua":"Назва програми","en":"Program name","ru":"Наименование программы"},"type":"text","value":"empty","comment":{"ua":"Коротка назва програми (3..20 символів)","en":"Short name of the program (3..2 characters)","ru":"Короткое имя программы (3..20 символов)"},"editable":true}}},"ClassTask_Heating":{"id":"ClassTask_Heating","ln":"ClassTaskThermal()::","header":{"ua":"Нагрівання","en":"Heating","ru":"Нагревание"},"type":"regsList","comment":{"ua":"Немає опису","en":"Note not defined","ru":"Описания нет"},"editable":true,"regs":{"tT":{"id":"tT","ln":"ClassReg_number(tT)::","header":{"ua":"T,°C","en":"T,°C","ru":"T,°C"},"type":"number","value":0,"comment":{"ua":"Цільова температура","en":"Task temperature","ru":"Целевая температура"},"editable":true,"min":0,"max":150},"errTmin":{"id":"errTmin","ln":"ClassReg_number(errTmin)::","header":{"ua":"errTmin,°C","en":"errTmin,°C","ru":"errTmin,°C"},"type":"number","value":0,"comment":{"ua":"Макс. відх. вниз (0=вимкн)","en":"Limit of low temperature (0=disable)","ru":"Макс. откл. вниз (0=выкл)"},"editable":true,"min":-100,"max":0},"errTmax":{"id":"errTmax","ln":"ClassReg_number(errTmax)::","header":{"ua":"errTmax,°C","en":"errTmax,°C","ru":"errTmax,°C"},"type":"number","value":0,"comment":{"ua":"Макс. відх. вверх (0=вимкн)","en":"Limit of high temperature (0=disable)","ru":"Макс. откл. вверх (0=выкл)"},"editable":true,"min":0,"max":100},"regMode":{"id":"regMode","ln":"ClassReg_select(regMode)::","header":{"ua":"Регулювання","en":"Regulation","ru":"Регулирование"},"type":"select","value":"pid","comment":{"ua":"Закон регулювання","en":"Control type","ru":"Закон регулирования"},"editable":true,"regs":{"pos":{"id":"pos","ln":"ClassReg_regsList(pos)::","header":{"ua":"Позиційний","en":"Positional","ru":"Позиционный"},"type":"regsList","comment":{"ua":"Позиційний закон регулювання","en":"Positional regulation","ru":"Позиционный закон регуллирования"},"editable":true,"regs":{"o":{"id":"o","ln":"ClassReg_number(o)::","header":{"ua":"Неузгодження","en":"Difference","ru":"Рассогласование"},"type":"number","value":-2,"comment":{"ua":"Неузгодження температур,°С","en":"Temperature difference,°С","ru":"Рассогласование температур,°С"},"editable":true,"min":-20,"max":0}}},"pid":{"id":"pid","ln":"ClassReg_regsList(pid)::","header":{"ua":"ПІД","en":"PID","ru":"ПИД"},"type":"regsList","comment":{"ua":"ПІД закон регулювання","en":"PID regulation","ru":"ПИД закон регуллирования"},"editable":true,"regs":{"o":{"id":"o","ln":"ClassReg_number(o)::","header":{"ua":"П","en":"P","ru":"П"},"type":"number","value":5,"comment":{"ua":"Пропорційна складова","en":"Proportional gain","ru":"Пропорциональная составляющая"},"editable":true,"min":0,"max":100},"ti":{"id":"ti","ln":"ClassReg_number(ti)::","header":{"ua":"І","en":"I","ru":"И"},"type":"number","value":5,"comment":{"ua":"Інтегральна складова","en":"Integral gain","ru":"Интегральная составляющая"},"editable":true,"min":0,"max":100},"td":{"id":"td","ln":"ClassReg_number(td)::","header":{"ua":"Д","en":"D","ru":"Д"},"type":"number","value":5,"comment":{"ua":"Диференційна складова","en":"Differencial gain","ru":"Диферинциальная составляющая"},"editable":true,"min":0,"max":100}}}}},"wT":{"id":"wT","ln":"ClassReg_number(wT)::","header":{"ua":"wT,°C","en":"wT,°C","ru":"wT,°C"},"type":"number","value":0,"comment":{"ua":"Початок ПІД рег. (=0 вимкн.)","en":"Start PID regulation (=0 off)","ru":"Начало ПИД рег. (=0-выкл.)"},"editable":true,"min":-200,"max":0},"H":{"id":"H","ln":"ClassReg_timer(H)::","header":{"ua":"Нагрівання","en":"Heating","ru":"Нагревание"},"type":"timer","value":0,"comment":{"ua":"Час нагрівання (=0 - макс. швидко)","en":"Heating time (=0 quick)","ru":"Время нагревания (=0 макс. быстро)"},"editable":true,"min":0,"max":1439}}}}}' );
tasks.type = "select"
tasks.list = JSON.parse(  '[{"id":"description","name":"prg01","created":"2023-05-03T11:04:49.715Z","header":{"ua":"Опис програми","en":"Program description","ru":"Описание программы"},"note":"Короткий опис програми"},{"id":"ClassTask_Heating","tT":80,"errTmin":-15,"errTmax":15,"regMode":"pid","o":10,"i":10,"d":10},{"id":"ClassTask_Heating","tT":120,"errTmin":-10,"errTmax":10,"regMode":"pid","o":20,"i":20,"d":20},{"id":"TaskNitriding","kN":1.2,"regMode":"pid","o":10,"i":10,"d":10}]' );
tasks.container = document.getElementById( 'tasksContainer' );</script><script> // створюємо прапорці трасування, так як в нас багато файлів нам потрібно в кожному
// з них вмикати трасування окремо від інших , тому кожний файл з кодом
// перед виконанням свого коду запамятовує поточне значення trace в beforeTrace: 'beforeTrace=trace'
// після завершення відновлює попереднє значення 'trace=beforeTrace', таким чином модулі не будуть заважати іншим
let trace = 1,
  beforeTrace = 0;

// аналог list, але в ньому зберігаються всі створені js-об'єкти регістрів
// для швидкого доступу
tasks.model = {};
tasks.model.data = [];

/**
 * Створює пустий рядок кроку програми
 * @param {Array} list
 *
 */

// tasks.newStep = (prefix) => {
//   let trace = 1,
//     ln = `tasks.newStep(${prefix})::`;
//   trace ? console.log(ln + `Started!`) : null;
//   let el = new tasks.createStep({
//     prefix: prefix,
//     reg: tasks.reg,
//     container: tasks.container,
//     types: tasks.elementsTypes,
//   });
//   if (trace) {
//     console.log(ln + `el=`);
//     console.dir(el);
//   }
//   return el;
// };

tasks.model.renumber = (array, start = 1) => {
  if (!array) {
    array = tasks.model.data;
  }
  if (start < 1) {
    start = 1;
  }
  for (let i = start; i < array.length; i++) {
    const element = array[i];
    if (Array.isArray(element)) {
      // TODO це масив підкроків
      let msg = ln + "Паралельні кроки поки не підтримуються !!";
      console.error(msg);
      throw new Error(msg);
    }
    if (typeof element == "object" && element.hasOwnProperty("stepNumber")) {
      element.renumber(i);
    }
  }
}; //tasks.model.renumber

tasks.model.deleteStep = (stepNumber) => {
  stepNumber = parseInt(stepNumber);
  let model = tasks.model;
  console.log("======model======");
  console.dir(model);
  if (!stepNumber || stepNumber === 0 || stepNumber > model.data.length - 1) {
    throw new Error(`Uncompatible stepNumber=${stepNumber} ! `);
    return;
  }

  let trace = 1,
    ln = `tasks.model.deleteStep(${stepNumber})::`;
  trace ? console.log(ln + `Started!`) : null;

  if (model.data.length <= 2) {
    alert(
      {
        ua: `Не можливо видалити останній крок  ${stepNumber}!`,
        en: `You can't delete the last step N ${stepNumber}!`,
        ru: `Невозмозно удалить последний шаг N${stepNumber}!`,
      }[lang]
    );
    throw new Error(ln + `Last step can't be deleted ! `);
    return;
  }
  if (
    !confirm(
      {
        ua: `Ви дійсно бажаєте видалити крок N ${stepNumber}?`,
        en: `Are You really want to delete step N ${stepNumber}?`,
        ru: `Вы действительно хотите удалить шаг N${stepNumber}?`,
      }[lang]
    )
  ) {
    console.log(ln + "Cancelled by user.");
    return;
  }
  // find element
  let el = model.data[stepNumber];
  trace ? console.log(ln + `el=${el.prefix}`) : null;
  // delete from DOM
  document.getElementById(el.prefix).remove();
  // delete from tasks.model.data
  model.data.splice(stepNumber, 1);
  tasks.model.renumber();
};

tasks.model.insertStep = (stepNumber = 0) => {
  stepNumber = parseInt(stepNumber);

  if (!stepNumber) {
    // якщо попередній крок не вказано, то додаємо в кінець масиву
    stepNumber = tasks.model.data.length;
  }

  let trace = 1,
    ln = `tasks.model.insertStep(after N${stepNumber})::`;
  trace ? console.log(ln + `Started!`) : null;

  let model = tasks.model;

  // визначаємо тип кроку
  let stepType = undefined;
  let stepTypes = Object.keys(tasks.reg.regs);
  if (stepTypes.length <= 2) {
    // під номером [0] йде опис програми, тому якщо в stepTypes тільки 2 елементи
    // то у нас тільки один тип кроку, беремо його
    stepType = stepTypes[1];
  } else {
    // більше одного типу кроків, окно вибору
    // TODO Доробити цей варіант з модальним окном
    tasks.modalWindow.setHeader(
      {
        ua: `Виберіть тип кроку`,
        en: `Select step type`,
        ru: `Выберите тип шага`,
      }[lang]
    );
    tasks.modalWindow.window.show();
  }
  trace ? console.log(ln + `New stepType=${stepType}`) : null;

  // крок після якого додавати новий
  let previousStep = document.getElementById(model.data[stepNumber].prefix);

  let el = tasks.createStep({
    stepNumber: 99,
    id: stepType,
    //container: hiddenStep,
    previousStep: previousStep,
  });

  if (trace) {
    console.log(ln + `previousStep=`);
    console.dir(previousStep);
  }

  // додаємо крок в model.data
  model.data.splice(stepNumber + 1, 0, el);
  // перенумеровуємо список
  model.renumber();
  // видаляємо вміст прихованого поля
};

tasks.model.moveUp = (stepNumber = undefined) => {
  stepNumber = parseInt(stepNumber);
  if (!stepNumber || stepNumber < 2) {
    throw new Error(`Uncompatible stepNumber=${stepNumber} ! `);
    return;
  }
  let trace = 1,
    ln = `tasks.model.moveUp(${stepNumber})::`;
  trace ? console.log(ln + `Started!`) : null;
};

tasks.model.moveDown = (stepNumber = undefined) => {
  stepNumber = parseInt(stepNumber);
  if (!stepNumber || stepNumber > tasks.model.data.length - 1) {
    throw new Error(`Uncompatible stepNumber=${stepNumber} ! `);
  }
  let trace = 1,
    ln = `tasks.model.moveDown(${stepNumber})::`;
  trace ? console.log(ln + `Started!`) : null;
};

tasks.createStep = (props = {}) => {
  let reg = tasks.reg.regs[props.id];
  let el;
  if (reg) {
    el = new tasks.ClassCreateStep({
      //editable: false, //tasks.reg.editable,
      model: tasks.model,
      stepNumber: props.stepNumber,
      reg: reg,
      container: props.container ? props.container : tasks.container,
      types: tasks.elementsTypes,
      previousStep: props.previousStep,
    });
    if (props.values) {
      el.setValues(props.values);
    }
  }
  return el;
};

tasks.renderList = function () {
  let trace = 1,
    ln = "tasks.renderList()::";

  // очищуємо модель
  tasks.model.data = [];

  // TODO Костиль з описом програми потрібно рендер опису
  tasks.model.data.push({ name: "Програма 1" });

  // очищуємо контейнер
  this.container.innerHTML = "";

  // для скорочення коду
  let list = tasks.list;

  // ------- створюємо заголовок ----------
  let header = document.createElement("div");
  header.classList.add("row");
  let title = document.createElement("div");
  title.classList.add("col");
  title.innerHTML = `<h6>${tasks.header[lang]}</h6>`;
  header.appendChild(title);
  tasks.container.classList = "border";
  this.container.appendChild(header);

  // if (list.length == 0) {
  //   // список програм пустий крок
  //   tasks.model.data.push(tasks.newStep("st1"));
  //   return;
  // } //if (list.length == 0)

  let i = 0;
  for (i = 0; i < list.length; i++) {
    let step = list[i];
    let props = {
      id: step.id,
      stepNumber: i,
      values: step,
    };
    let el = tasks.createStep(props);
    // let reg = tasks.reg.regs[step.id];
    // // trace ? console.log(ln + `reg=${JSON.stringify(reg)}`) : null;
    // if (reg) {
    //   let el = new this.ClassCreateStep({
    //     //editable: false, //tasks.reg.editable,
    //     model: tasks.model,
    //     stepNumber: i,
    //     reg: reg,
    //     container: tasks.container,
    //     types: tasks.elementsTypes,
    //   });
    //   //tasks.container.appendChild(el.main);
    //   el.setValues(step);
    if (!el) {
      console.error(`Помилка створення кроку: ${JSON.stringify(props)}`);
      continue;
    }
    tasks.model.data.push(el);
    if (trace) {
      console.log(ln + `el=`);
      console.dir(el);
    }
    //tasks.model = el;
  } //for
  // i += 1;
  // if (tasks.reg.editable || list.length === 0) {
  //   tasks.model.data.push(tasks.newStep(`st${("0" + i).slice(-2)}`));
  //   return;
  // }
};

/** список доступних класів типів регістрів,
 * що створюють відповідні елементи
 * {select:ClassElementSelect, number:ClassElementNumber, ...}
 */
tasks.elementsTypes = {};
tasks.ClassCreateElement = class ClassCreateElement {
  /**
   * Створює налаштований DOM-елемент загального типу
   * @param {Object} props
   * @property {string} props.prefix - префікс для id елементу
   * @property {string} props.tag - тип елементу (number, range, select)
   * @property {Object} props.reg  - типовий регістр
   * @property {Object} props.container - контейнер в якому потрібно розмістити елемент
   */
  constructor(props = {}) {
    this.ln = "ClassCreateElement()::";
    let trace = 1,
      ln = this.ln + "constructror()::";
    trace ? console.log(ln + "props=") : null;
    trace ? console.dir(props) : null;
    // -- батьківський контейнер для елементу -----
    if (!props.container) {
      console.error(ln + "Не вказано батьківський контейнер!!!");
    } else {
      this.container = props.container;
    }
    // -- тег основного елемента, щоб створити шаблон
    this.tag = props.tag;
    // -- префікс -----
    this.prefix = props.prefix;
    // -- id -----
    this.id = props.reg.id;
    // -- регістр
    this.reg = props.reg;
    // тип регистру
    this.type = props.reg.type;

    // дозвіл на зміну значення
    this.readonly = props.reg.readonly;

    this.value = props.reg.value;
    this.beforeValue = props.reg.value;
    // -- id - елементу DOM
    this.elId = this.getElId();
    // контейнер для всього елементу
    this.div = document.createElement("div");
    this.div.id = this.getElId();
    this.div.classList.add("col");
    this.div.classList.add("form-group");
    // ---- <label=header> --------
    this.label = document.createElement("label");
    this.label.setAttribute("for", this.id);
    this.label.classList.add("h6");
    this.label.innerHTML = this.reg.header[lang];
    // ---- <comment> --------
    this.comment = document.createElement("small");
    this.comment.innerHTML = this.reg.comment[lang];
    // ---- Field --------
    this.field = document.createElement(this.tag);
    this.field.classList.add("form-control");
    this.field.classList.add(this.prefix);
    this.field.classList.add("field");
    this.field.id = this.elId + "_field";
    if (this.readonly) {
      this.field.classList.add("readonly");
    }
    this.div.appendChild(this.label);
    this.div.appendChild(this.field);
    this.div.appendChild(this.comment);
    // -- поточне значення -----
    if (props.reg.value | (props.reg.value === 0)) {
      this.value = props.reg.value;
      this.beforeValue = props.reg.value;
      this.setValue(this.value);
    }
    // додаємо в контейнер елемент
    this.container.appendChild(this.div);
    // привязуємо this до обробника до this
    this.field.onchange = this.onchange.bind(this);
  }

  onchange(event) {
    let ln = this.ln + "onchange()::";
    if (trace) {
      console.log(ln + "this=");
      console.dir(this);
    }
    trace ? console.log(ln + "this.field.value=" + this.getFieldValue()) : null;
    //this.setValue(this.getFieldValue());
  }

  // створює ідентифікатор для елементу DOM
  getElId(id = null) {
    id = id === null ? this.id : id;
    return this.prefix + "__" + id; //два підкреслення (щоб легко відділяти id регістру)
  }

  setValue(val) {
    let trace = 0,
      ln = this.ln + `setValue(${val})::`;
    trace
      ? console.log(
          ln +
            `Started:this.beforeValue=${this.beforeValue};this.value=${this.value}`
        )
      : null;
    trace = 1;
    this.value = val;
    this.beforeValue = this.value;
    trace
      ? console.log(
          ln +
            `Finished:this.beforeValue=${this.beforeValue};this.value=${this.value}`
        )
      : null;
    this.field.value = val;
    this.reg.value = val;
  }

  setProperty(key, value) {
    console.log(this.ln + `setProperty[${key}]=${value}. Поки не реалізовано!`);
  }

  getBeforeValue() {
    return this.beforeValue;
  }

  /**
   * @return true якщо елемент змінився
   */

  hasChanged() {
    let trace = 1,
      ln = this.ln + "hasChanged()::";

    let res;
    res =
      this.beforeValue == undefined
        ? true
        : this.getFieldValue() != this.getBeforeValue();
    trace
      ? console.log(
          ln +
            `this.getBeforeValue()=${this.getBeforeValue()};this.getFieldValue()=${this.getFieldValue()}; res=${res}`
        )
      : null;
    return res;
  }

  getFieldValue() {
    return this.field.value;
  }
};
// -----------  element: select -------------------
beforeTrace = trace;
trace = 1;

/**
 * Створює елемент вибору select
 *
 */
class ClassElementSelect extends tasks.ClassCreateElement {
  constructor(props = {}) {
    props.tag = "select";
    super(props);
    this.ln = "ClassElementSelect(" + props.reg.id + ")::";
    let trace = 1,
      ln = this.ln + "Constructor()::";
    this.regs = this.reg.regs;

    // створюємо список <option>
    let keys = "";
    let first = true;
    for (let key in this.regs) {
      if (this.regs.hasOwnProperty(key)) {
        let trace = 1;
        let selected = "";
        // якщо this.value не вказано, то перший елемент в списку опцій обирається автоматично браузером
        if (!first & (keys == this.value)) {
          selected = "selected";
          //   // якщо це перша опція, вибираємо її як початкову
          //   this.setValue(field.value = key;
          //   this.field.dataset.beforeValue = key;
        }
        trace ? console.log(ln + "key=" + key) : null;
        keys += `<option value='${key}' ${selected}> ${this.reg.regs[key].header[lang]} </option>`;
      }
    } //for
    // -- опції вибору -------
    this.field.innerHTML = keys;
    // -- обробник зміни значення поля ----------
    this.field.onchange = this.onchange.bind(this);
    // -- початкова ініціалізація -----------
    this.value = this.getFieldValue();
    trace ? console.log(ln + `this.value=${this.value}`) : null;

    // create children
    this.children = new tasks.ClassRegsList({
      container: this.container,
      prefix: this.elId,
      regs: this.regs[this.value].regs,
      types: this.types,
    });

    this.setValue(this.value);

    if (trace) {
      console.log(ln + `this.getFieldValue()=${this.getFieldValue()}`);
      console.dir(this);
    }
  }

  onchange(event) {
    let ln = this.ln + "onchange()::elem_select()::";
    let trace = 1;
    if (!this.hasChanged()) {
      return;
    }
    // this.children.remove();
    // this.render(this.regs[this.getFieldValue()]);
    this.setValue(this.getFieldValue());
    super.onchange(event);
  }

  setValue(val) {
    let trace = 1,
      ln = this.ln + `setValue(${val})::`;
    trace ? console.log(ln + `Started`) : null;
    super.setValue(val);
    this.children.remove();
    this.children.render(this.regs[val].regs);
  }
}

tasks.elementsTypes["select"] = ClassElementSelect;

trace = beforeTrace;
// -----------  element: select -------------------
beforeTrace = trace;
trace = 1;
/**
 * Створює та повертає елемент вибору
 *
 */
class ClassElementNumber extends tasks.ClassCreateElement {
  constructor(props = {}) {
    props.tag = "input";
    super(props);
    this.ln = "ClassElementNumber(" + props.reg.id + ")::";
    let trace = 1,
      ln = this.ln + "Constructor()::";

    // -- тип поля Number -------
    this.field.setAttribute("type", "number");

    // -- обробник зміни значення поля ----------
    this.field.onchange = this.onchange.bind(this);

    if (props.reg.min | (props.reg.min === 0)) {
      this.field.setAttribute("min", props.reg.min);
      this.min = props.reg.min;
    }

    if (props.reg.max | (props.reg.max === 0)) {
      this.field.setAttribute("max", props.reg.max);
      this.max = props.reg.max;
    }

    this.field.setAttribute("value", props.reg.value);
    if (trace) {
      console.log(ln + "this=");
      console.dir(this);
    }
  }
  onchange(event) {
    let trace = 1,
      ln = this.ln + "onchange()::";
    super.onchange(event);
    let val = this.getFieldValue();
    this.setValue(val);
    //this.field.value = this.value;
  } // onchange()

  setValue(val) {
    if (val > this.max) {
      console.error(
        this.ln +
          `Can't set ${val}, because max=${this.max}. Was setted max value!`
      );
      val = this.max;
    }
    if (val < this.min) {
      val = this.min;
      console.error(
        this.ln +
          `Can't set ${val}, because min=${this.min}. Was setted min value!`
      );
    }
    super.setValue(val);
  }
} // class

tasks.elementsTypes["number"] = ClassElementNumber;

trace = beforeTrace;
// -----------  element: select -------------------
beforeTrace = trace;
trace = 1;

/**
 * Створює елемент для вводу часу
 *
 */

//

tasks.elementsTypes["timer"] = class ClassElementTimer extends (
  tasks.ClassCreateElement
) {
  constructor(props = {}) {
    props.tag = "input";
    super(props);
    this.ln = "ClassElementTimer(" + props.reg.id + ")::";
    let trace = 1,
      ln = this.ln + "Constructor()::";

    // -- тип поля  -------
    this.field.setAttribute("type", "time");

    // хв, мінімальне значення
    this.min = 0;
    if (props.reg.min || props.reg.min === 0) {
      this.min = props.reg.min;
    }
    this.field.setAttribute("min", this.minutesToString(this.min));

    // хв, максимальне значення
    this.max = 99 * 60; //99 годин
    if (props.reg.max | (props.reg.max === 0)) {
      this.max = props.reg.max;
    }
    this.field.setAttribute("max", this.minutesToString(this.max));

    // встановлюємо значення поля
    this.field.value = this.minutesToString(this.value);

    if (trace) {
      console.log(ln + "this=");
      console.dir(this);
    }
  }
  onchange(event) {
    let trace = 1,
      ln = this.ln + "onchange()::";
    super.onchange(event);
    let val = this.getFieldValue();
    this.setValue(this.stringToMinutes(val));
    //this.field.value = this.value;
  } // onchange()

  /**
   * Вираховує кількість хвилин в hhmm
   * @param {String} hhmm - час в форматі "00:00"
   */
  stringToMinutes(hhmm = "00:00") {
    let ln = this.ln + `stringToMinutes(${hhmm})::`;
    let arr = hhmm.split(":");
    if (arr.length > 2) {
      throw Error(ln + `Невірний формат аргументу`);
    }
    let val = parseInt(arr[0]) * 60 + parseInt(arr[1]);
    return val;
  }

  minutesToString(minutes) {
    let time = new Date(minutes * 60 * 1000).toISOString();
    //console.log(time);
    return time.slice(11, -8);
  }

  setValue(val) {
    if (val > this.max) {
      console.error(
        this.ln +
          `Can't set ${val}, because max=${this.max}. Was setted max value!`
      );
      val = this.max;
    }
    if (val < this.min) {
      val = this.min;
      console.error(
        this.ln +
          `Can't set ${val}, because min=${this.min}. Was setted min value!`
      );
    }
    super.setValue(val);
    this.field.value = this.minutesToString(val);
  }
}; // class

trace = beforeTrace;
// -----------  element: select -------------------
beforeTrace = trace;
trace = 1;
/**
 * Створює та повертає елемент вибору
 *
 */
tasks.elementsTypes["textarea"] = class ClassElementNumber extends (
  tasks.ClassCreateElement
) {
  constructor(props = {}) {
    props.tag = "textarea";
    super(props);
    this.ln = "ClassElementTextArea(" + props.reg.id + ")::";
    let trace = 1,
      ln = this.ln + "Constructor()::";

    // -- тип поля Number -------
    this.field.setAttribute("rows", "3");

    // -- обробник зміни значення поля ----------
    // 2024-01-31 перенесено в батьківський клас
    // this.field.onchange = this.onchange.bind(this);

    this.field.setAttribute("value", props.reg.value);
    if (trace) {
      console.log(ln + "this=");
      console.dir(this);
    }
  }
  onchange(event) {
    let trace = 1,
      ln = this.ln + "onchange()::";
    super.onchange(event);
    let val = this.getFieldValue();
    this.setValue(val);
    //this.field.value = this.value;
  } // onchange()

  // setValue(val) {
  //   if (val > this.max) {
  //     console.error(
  //       this.ln +
  //         `Can't set ${val}, because max=${this.max}. Was setted max value!`
  //     );
  //     val = this.max;
  //   }
  //   if (val < this.min) {
  //     val = this.min;
  //     console.error(
  //       this.ln +
  //         `Can't set ${val}, because min=${this.min}. Was setted min value!`
  //     );
  //   }
  //   super.setValue(val);
  // }
}; // class

trace = beforeTrace;
// -----------  element: select -------------------
beforeTrace = trace;
trace = 1;
/**
 * Створює та повертає елемент вибору
 *
 */
tasks.elementsTypes["text"] = class ClassElementNumber extends (
  tasks.ClassCreateElement
) {
  constructor(props = {}) {
    props.tag = "input";
    super(props);
    this.ln = "ClassElementTextArea(" + props.reg.id + ")::";
    let trace = 1,
      ln = this.ln + "Constructor()::";

    // -- тип поля Number -------
    this.field.setAttribute("type", "text");
    this.field.setAttribute("maxlength", "20");
    this.field.setAttribute("size", "22");

    // -- обробник зміни значення поля ----------
    // 2024-01-31 перенесено в батьківський клас
    // this.field.onchange = this.onchange.bind(this);

    this.field.setAttribute("value", props.reg.value);
    if (trace) {
      console.log(ln + "this=");
      console.dir(this);
    }
  }
  onchange(event) {
    let trace = 1,
      ln = this.ln + "onchange()::";
    super.onchange(event);
    let val = this.getFieldValue();
    this.setValue(val);
    //this.field.value = this.value;
  } // onchange()

  // setValue(val) {
  //   if (val > this.max) {
  //     console.error(
  //       this.ln +
  //         `Can't set ${val}, because max=${this.max}. Was setted max value!`
  //     );
  //     val = this.max;
  //   }
  //   if (val < this.min) {
  //     val = this.min;
  //     console.error(
  //       this.ln +
  //         `Can't set ${val}, because min=${this.min}. Was setted min value!`
  //     );
  //   }
  //   super.setValue(val);
  // }
}; // class

trace = beforeTrace;
// -----------  element: select -------------------
beforeTrace = trace;
trace = 1;
/**
 * Створює та повертає список об'єктів регістрів та їх DOM - елементи
 *
 */
tasks.ClassRegsList = class ClassRegsList {
  /**
   * Створює контейнер з регістрами
   * @param {*} props
   * @property {DOMnode} props.container - DOM контенер в якому буде розміщено
   * @property {String} props.prefix - префікс до id
   * @property {Object} props.regs - список регістрів
   * @property {Object} props.types - список доступних класів, що рендерять елементи
   */
  #type = "regsList";

  constructor(props = {}) {
    this.ln = `ClassRegsList(${props.prefix})::`;
    let trace = 1,
      ln = this.ln + "сonstructor()::";
    //
    if (trace) {
      console.log(ln + `props=`);
      console.dir(props);
    }
    // тип
    // this.type = "listRegs";
    // об'єкт, що містить в собі список доступних типів (класів) регістрів,
    // що використовуються для їх створення
    if (!props.types) {
      // TODO Виправити костиля. Ймовірно список типів
      // потріпно зберігати у властивостях класу  ClassRegsList.types
      // в цьому разі він буде завжди з цим класом
      props.types = tasks.elementsTypes;
      //throw new Error(ln + "'props.types' not defined !!");
    }
    this.types = props.types;

    // список регістрів
    if (!props.regs) {
      throw new Error(ln + "'props.regs' not defined !!");
      props.regs = {};
    }
    //this.regs = props.regs;

    // prefix
    this.prefix = props.prefix ? props.prefix : "undefined_";

    // контейнер DOM, в якому буде розміщено елемент
    if (!props.container) {
      throw new Error(
        ln + "'props.container' not defined !! Was selected 'document.body' "
      );
      props.container = document.body;
    }
    this.container = props.container;

    // список дітей, елементу

    this.children = {};

    // -- початкова ініціалізація -----------
    this.render(props.regs);

    if (trace) {
      console.log(ln + `Was created element. this=${""}`);
      console.dir(this);
    }
  }

  onchange(event) {}

  remove() {
    let trace = 1,
      ln = this.ln + `remove(${this.prefix})::`;
    let regs = this.children;
    for (let key in regs) {
      let lln = ln + `child[${key}]::`;
      trace ? console.log(ln + `key=${key}`) : null;
      if (regs.hasOwnProperty(key)) {
        let child = regs[key];

        let el = document.getElementById(child.div.id);
        if (el) {
          el.remove();
        }
        trace
          ? console.log(
              lln + `Was removed element from DOM id= ${child.div.id} )`
            )
          : null;
        regs[key] = undefined;
      } //if (regs.hasOwnProperty(key))
    } //for
    this.children = {};
    console.log(ln + "Completed!");
  }

  render(regs) {
    let trace = 1,
      ln = this.ln + `render(${this.prefix})::`;
    trace ? console.log(ln + `Started`) : null;
    trace ? console.log(ln + `regs=${regs}`) : null;
    this.children = {};
    for (let key in regs) {
      trace ? console.log(ln + `key=${key}`) : null;
      if (regs.hasOwnProperty(key)) {
        let trace = 1;
        let item = regs[key];
        trace
          ? console.log(
              ln +
                `for (key=${key}) item.id= ${item.id}; item.type=${item.type} )`
            )
          : null;

        if (this.types[item.type]) {
          // тип регістру визначений, визиваємо його конструктор
          let el = new this.types[item.type]({
            prefix: this.prefix,
            reg: item,
            container: this.container,
          });
          // перевіряємо чи є елемент з таким id в DOM
          if (document.getElementById(el.idEl)) {
            throw Error(
              ln + `DOM element with id = ${el.idEl} already presented!!`
            );
          }
          // додаємо в дерево DOM
          this.container.appendChild(el.div);
          // запамятовуємо в списку дітей
          this.children[el.id] = el;
          trace
            ? console.log(ln + `Created element DOM id= ${el.elId} )`)
            : null;
        } else {
          console.error(
            ln +
              `Not found in tasks.elementsTypes(=this.types) type: item.type=${item.type}`
          );
        } //if
      } //if (regs.hasOwnProperty(key))
    } // for
    trace
      ? console.log(ln + `Created this.children=${Object.keys(this.children)}`)
      : null;
  } //renderRegs()

  /**
   * Збирає значення регістрів всіх дітей
   * @returns {Object} {reg1.id:reg1.value, reg2.id:reg2.value, } for example {'tT':500,'o':15,..}
   */
  getValues() {
    let trace = 0,
      ln = this.ln + ` getValues(${this.prefix})::`;
    let children = this.children;
    let res = {};
    for (let key in children) {
      if (children.hasOwnProperty(key)) {
        let lln = ln + `for (${key})::`,
          trace = 0;
        let child = children[key];
        if (trace) {
          console.log(lln + `child=`);
          console.dir(child);
        }
        res[child.id] = child.value;
        if (child.children) {
          let resChild = child.children.getValues();
          Object.assign(res, resChild);
        }
      }
    }
    //trace = 1;
    if (trace) {
      console.log(ln + `Response=`);
      console.dir(res);
    }
    return res;
  } //getValues()

  // /**
  //  *
  //  * @param {Object} values - {'tT':500,...} or {'tT':{value:500,enable:true,...},...}
  //  */
  // setValues(values) {
  //   let trace = 0,
  //     ln = this.ln + ` setValues(${this.prefix})::`;
  //   let children = this.children;

  //   for (let key in values) {
  //     if (values.hasOwnProperty(key)) {
  //       let el = values[key];
  //     } //if (regs.hasOwnProperty(key))
  //   } // for
  // } //setValues(values)

  setRegister(id, value) {
    let trace = 0,
      ln = this.ln + `setRegister(${id};${value})::`;
    trace ? console.log(ln + `Started`) : null;
    let reg = this.findRegister(id);
    if (reg) {
      // регістр знайдено
      if (typeof value != "object") {
        reg.setValue(value);
        return value;
      }
      // якщо value - об'экт зі значеннями, то перебираємо ці значення
      for (let key in value) {
        if (value.hasOwnProperty(key)) {
          if (reg[key]) {
            // поле key  в регістрі знайдено
            reg[key].setProperty(key, value[key]);
          }
        } //for
      }
    } // setRegister(id,values)
  }

  /**
   * Знаходить серед дітей регістр з вказаним id
   * @param {String} id
   * @return {undefined | Object }
   */
  findRegister(id) {
    let trace = 0,
      ln = this.ln + `findRegister(${id}})::`;
    trace ? console.log(ln + `Started`) : null;

    let res = this.children[id];

    if (!res) {
      // якщо при прямому пошуку не знайдено
      // шукаємо в регістрах з дітьми
      for (let key in this.children) {
        if (this.children.hasOwnProperty(key)) {
          if (this.children[key].children) {
            res = this.children[key].children.findRegister(id);
            if (res) {
              break;
            }
          }
        }
      } //for
    }
    return res;
  }
}; // Class

trace = beforeTrace;
// -----------  element: select -------------------
beforeTrace = trace;
trace = 1;
/**
 * Створює та повертає елемент вибору
 *
 */
tasks.ClassCreateStep = class ClassCreateStep {
  /**
   * Створює контейнер з регістрами
   * @param {*} props
   * @property {DOMnode} props.container - DOM контенер в якому буде розміщено крок
   * @property {String} props.stepNumber - номер кроку в tasks.model.data "01","02:02"
   * @property {Object} props.reg - регістр, що містить в собі опис кроку
   * @property {Object} props.types - список доступних класів, що рендерять елементи
   * @property {Object} props.previousStep=undefined - елемент DOM після якого вставляти новий крок
   */

  constructor(props = {}) {
    this.ln = "ClassCreateStep(" + props.reg.id + ")::";

    let trace = 1,
      ln = this.ln + "Constructor()::";
    if (trace) {
      console.log(ln + `props=`);
      console.dir(props);
    }
    //
    if (!props.reg) {
      throw new Error(ln + "No item 'props.reg' defined");
    }
    this.reg = props.reg;
    // for testing this.reg.editable = false;
    // номер кроку
    if (!props.stepNumber && props.stepNumber != 0) {
      throw new Error(ln + "No item 'props.stepNumber' defined");
    }
    this.stepNumber = props.stepNumber;

    // створюємо унікальний префікс
    this.prefix = "id" + `${new Date().getTime().toString().slice(-6)}`;

    // this.types
    if (!props.types) {
      throw new Error(ln + "No item 'props.types' defined");
    }
    this.types = props.types;

    // this.model
    if (!props.model) {
      throw new Error(ln + "No item 'props.model' defined");
    }
    this.model = props.model;

    // створюємо контейнер для кроку
    this.main = document.createElement("div");
    this.main.classList.add("container");
    this.main.classList.add("border");
    this.main.classList.add("border-secondary");
    this.main.id = this.prefix;

    // ------- додаємо контейнер в документ --------
    if (props.previousStep === undefined) {
      // попередній елемент не вказано,
      if (!props.container) {
        // контейнер не вказано - Помилка
        throw new Error(ln + "No props.container defined");
        return;
      } else {
        //додаємо rhjr в кінець контейнера
        props.container.appendChild(this.main);
      }
    } else {
      // вставляємо крок після попереднього елементу
      props.previousStep.after(this.main);
    }

    //  створюємо заголовок

    {
      let trace = 1;
      let header = document.createElement("div");
      header.classList.add("row");

      // номер кроку
      let numberCol = document.createElement("div");
      numberCol.classList.add("col-md-auto");
      this.numberField = document.createElement("span");
      this.numberField.classList.add("h5");
      this.renumber(this.stepNumber);
      numberCol.appendChild(this.numberField);
      header.appendChild(numberCol);

      // тип кроку
      let headerCol = document.createElement("div");
      headerCol.classList.add("col");
      let headerTitle = document.createElement("span");
      headerTitle.classList.add("h5");
      headerTitle.innerHTML = this.reg.header[lang];
      headerCol.appendChild(headerTitle);
      header.appendChild(headerCol);

      if (this.reg.editable) {
        header.appendChild(this.buttonsEditCreate());
      }

      // if (trace) {
      //   console.log(ln + `Type "regsList" was found. Created header=`);
      //   console.dir(header);
      // }

      this.main.appendChild(header);
    }

    // створюємо рядок, в якому буде розташовуватися вміст кроку
    let row = document.createElement("div");
    row.classList.add("row");
    row.id = this.prefix + "_row";
    this.main.appendChild(row);
    this.container = row;

    // рендеримо дітей
    this.children = new tasks.ClassRegsList({
      prefix: this.prefix,
      container: this.container,
      //parent: this,
      regs: this.reg.regs,
      types: this.types,
    });
    // console.log("------ getValues -------");
    // console.log(this.children.getValues());

    if (trace) {
      console.log(ln + `this=${""}`);
      console.dir(this);
    }
  }

  renumber(newNumber) {
    this.stepNumber = newNumber;
    this.numberField.innerHTML = "№ " + ("00" + this.stepNumber).slice(-2);
  }

  /**
   * Створює та повертає группу кнопок редагування
   */
  buttonsEditCreate() {
    // ---------- кнопки керування --------------------

    let buttonGroupe = document.createElement("div");
    buttonGroupe.classList.add("col-md-auto");
    buttonGroupe.classList.add("btn-group");
    buttonGroupe.setAttribute("role", "group");
    buttonGroupe.setAttribute("aria-label", "edit buttons");
    buttonGroupe.setAttribute("data-parent", this.prefix);

    /** Функція створює стандартну кнопку DOM та повертає її
     * @param {Object} props - список налаштувань
     * @property {Object} props.this - посилання на поточний об'єкт кроку
     * @property {String} props.style - стиль кнопки, наприклад "btn-info"
     * @property {Object} props.title - спливаюча підказка { ua:`` , en: ``, ru: `` };
     * @property {String} props.innerHTML - внутрішній код
     * @property {function} props.onclick - подія натискання
     * @returns {DOM-element} - DOM елемент кнопки
     */

    let createButton = (props = {}) => {
      let but = document.createElement("button");
      but.classList.add("btn");
      but.classList.add(props.style ? props.style : "btn-secondary");
      but.id = props.this.prefix + (props.name ? props.name : "noNameButton");
      but.setAttribute(
        "title",
        props.title
          ? props.title[lang]
          : {
              ua: `Немає опису`,
              en: `Undefined description`,
              ru: `Нет описания`,
            }[lang]
      );
      but.innerHTML = props.innerHTML ? props.innerHTML : "<h6>???</h6>";

      // but.onclick = props.onclick ? props.onclick.bind(this) : undefined;
      but.onclick = props.this.button_onclick
        ? props.this.button_onclick.bind(props.this)
        : undefined;
      return but;
    };

    // -- buttom UP
    let but_up = createButton({
      style: "btn-secondary",
      name: "_up",
      title: { ua: `Вище`, en: `Move up`, ru: `Вверх` },
      innerHTML: "<h6>&#9650;</h6>",
      this: this,
    });
    buttonGroupe.appendChild(but_up);

    // -- buttom DOWN

    let but_down = createButton({
      style: "btn-secondary",
      name: "_down",
      title: { ua: `Нижче`, en: `Move down`, ru: `Вниз` },
      innerHTML: "<h6>&#9660;</h6>",
      this: this,
    });

    buttonGroupe.appendChild(but_down);

    // -- buttom insert
    let but_insert = createButton({
      style: "btn-primary",
      name: "_insert",
      title: { ua: `Додати крок`, en: `Add step`, ru: `Добавить шаг` },
      innerHTML: "<h6>+</h6>",
      this: this,
    });
    buttonGroupe.appendChild(but_insert);

    // -- buttom DELETE
    let but_del = createButton({
      style: "btn-danger",
      name: "_del",
      title: { ua: `Видалити`, en: `Delete`, ru: `Удалить` },
      innerHTML: "<h6>X</h6>",
      this: this,
    });

    buttonGroupe.appendChild(but_del);
    return buttonGroupe;
  }

  button_onclick(ev) {
    let target = ev.target;
    //
    if (!target.id) {
      target = target.parentNode;
    }

    let id = target.id;

    let trace = 1,
      ln = this.ln + `button_onclick()::`; //
    trace
      ? console.log(ln + `Was pressed button [${id ? id : target.tagName}]!`)
      : null;
    let action = id.split("_").slice(-1)[0];
    trace ? console.log(ln + `Action is [${action}]!`) : null;
    //console.dir(target);
    switch (action) {
      case "del":
        this.model.deleteStep(this.stepNumber);
        break;
      case "up":
        this.model.moveUp(this.stepNumber);
        break;
      case "down":
        this.model.moveDown(this.stepNumber);
        break;
      case "insert":
        this.model.insertStep(this.stepNumber);
        break;
      default:
        console.error(ln + `Action "${action}" not finded!`);
        break;
    }
  }
  // onchange(event) {}
  getValues() {
    let res = {};
    res["id"] = this.reg.id;
    return Object.assign(res, this.children.getValues());
  }

  setValues(values) {
    let trace = 1,
      ln = this.ln + `setValues()::`;
    trace ? console.log(ln + `Started`) : null;
    for (let key in values) {
      if (values.hasOwnProperty(key)) {
        trace ? console.log(ln + `for(key=${key})=${values[key]}`) : null;
        this.children.setRegister(key, values[key]);
      } // if (value.hasOwnProperty(key))
    } //for
  }
}; // ClassCreateStep

trace = beforeTrace;
tasks.modalWindow = {};

tasks.modalWindow = new (class ModalWindow {
  constructor(props = {}) {
    this.header = props.header ? props.header : "Undefined";
    this.id = props.id
      ? props.id
      : "modal_" + new Date().getTime().toString().slice(-6);

    // there are saving links to DOM elements
    this.dom = {};

    // this.data - result of working modal window

    this.data = { canceled: false };

    let el;
    // -------- window --------------
    this.dom["window"] = el = document.createElement("div");
    // el =  this.dom.window;
    el.className = "modal fade";
    el.setAttribute("tabindex", "-1");
    el.setAttribute("data-bs-backdrop", "static");
    el.setAttribute("data-bs-keyboard", "false");
    el.id = this.id;

    document.body.appendChild(this.dom.window);

    // modal-dialog
    this.dom.dialog = el = document.createElement("div");
    el.className = "modal-dialog";
    this.dom.window.appendChild(this.dom.dialog);

    // content
    this.dom.content = el = document.createElement("div");
    el.className = "modal-content";
    this.dom.dialog.appendChild(this.dom.content);

    // header
    this.dom.header = el = document.createElement("div");
    el.className = "modal-header";
    el.id = this.id + "_header";
    el.innerHTML = this.header;
    this.dom.content.appendChild(this.dom.header);
    // body
    this.dom.body = el = document.createElement("div");
    el.className = "modal-body";

    let container = document.createElement("div");
    container.className = "container-fluid";
    container.id = this.id + "_body";

    el.appendChild(container);
    this.dom.content.appendChild(this.dom.body);
    // footer
    this.dom.footer = el = document.createElement("div");
    el.className = "modal-footer";
    el.id = this.id + "_footer";
    this.dom.content.appendChild(this.dom.footer);
    // footer.bCancel
    this.dom.footer.bCancel = el = document.createElement("button");
    el.className = "btn btn-secondary";
    el.setAttribute("type", "button");
    //el.setAttribute("aria-label", "Cancel");
    el.onclick = () => {
      console.log("Cancel clicked!");
      this.data = { canceled: true };
      this.window.hide();
    };
    el.innerText = { ua: `Відміна`, en: `Cancel`, ru: `Отмена` }[lang];

    this.dom.footer.appendChild(el);

    // властивість для керування вікном
    this.window = new bootstrap.Modal(this.dom.window, {
      keyboard: false,
      backdrop: "static",
    });
  } //constructor
  setHeader(content) {
    this.dom.header.innerHTML = content;
  }
  setBody(content) {
    this.dom.body.innerHTML = content;
  }
  setFooter(content) {}
})();
</script><script>//- запускаємо відображення списку кроків програми
tasks.renderList();

</script><div class="row"><div class="col"><button class="btn btn-primary" type="button" id="buttonTasksAccept">Застосувати</button></div></div><script>buttonTasksAccept.onclick = (e) => {
  let el = document.createElement("pre");
  let modelData = tasks.model.data;
  let data = [];
  for (let i = 1; i < modelData.length; i++) {
    data.push(modelData[i].getValues());
  }
  el.innerText = JSON.stringify(data);
  tasks.container.appendChild(el);
};
</script></div></div></div></div><script src="/bootstrap/bootstrap.min.js"></script></body></html>