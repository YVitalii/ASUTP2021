<!DOCTYPE html><html class="h-100"><head><title>pageTitle: not defined</title><link rel="stylesheet" href="/stylesheets/style.css"><link rel="stylesheet" href="/bootstrap/bootstrap.min.css"><script src="/bootstrap/bootstrap.bundle.min.js"> </script><script>function getDate() {
  var date = new Date().toLocaleString();
  let arr = date.split(",");
  date = arr[0] + "<br>" + arr[1];

  document.getElementById("timedisplay").innerHTML = date.toLocaleString();
}
setInterval(getDate, 0);
</script><script>var pageProps={};
var lang = "ua";</script></head><body class="h-100"><div class="container-fluid h-100 d-flex flex-column"> <div class="row"><div class="col-3"><img src="/img/logo_bortek.png" alt="Бортек" id="logo"></div><div class="col my-auto mx-auto "><div class="h2 " id="pageTitle">pageTitle: not defined</div></div><div class="col-1 my-auto mx-auto "><div class="h5" id="timedisplay"></div></div><hr></div><div class="row h-100"><div class="col"><div class="h-100" id="pageBody"><p>--------------------- debugging info manager = -----------------------------<pre>manager.fileManager={&quot;homeDir&quot;:&quot;F:\\node\\ASUTP2021\\controllers\\tasksController\\tests\\tasks&quot;,&quot;ln&quot;:&quot;ClassTasksManager::ClassFileManager::&quot;,&quot;homeURL&quot;:&quot;/fileManager/&quot;,&quot;filesList&quot;:[&quot;default.json&quot;,&quot;task01.json&quot;,&quot;колесаВеликі відпал.json&quot;],&quot;reg&quot;:{&quot;id&quot;:&quot;tasksList&quot;,&quot;ln&quot;:&quot;ClassReg_regsList(tasksList)::&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;Робота зі списком завдань&quot;,&quot;en&quot;:&quot;Working with list of tasks&quot;,&quot;ru&quot;:&quot;Работа со списком заданий&quot;},&quot;type&quot;:&quot;regsList&quot;,&quot;comment&quot;:{&quot;ua&quot;:&quot;&quot;,&quot;en&quot;:&quot;&quot;,&quot;ru&quot;:&quot;&quot;},&quot;editable&quot;:true,&quot;regs&quot;:{&quot;fileNames&quot;:{&quot;id&quot;:&quot;fileNames&quot;,&quot;ln&quot;:&quot;ClassRegister(fileNames)::&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;Перелік програм&quot;,&quot;en&quot;:&quot;The list of programs&quot;,&quot;ru&quot;:&quot;Список программ&quot;},&quot;type&quot;:&quot;simpleSelect&quot;,&quot;comment&quot;:{&quot;ua&quot;:&quot;Виберіть програму&quot;,&quot;en&quot;:&quot;Select program&quot;,&quot;ru&quot;:&quot;Выберите програму&quot;},&quot;editable&quot;:true,&quot;list&quot;:[&quot;default.json&quot;,&quot;task01.json&quot;,&quot;колесаВеликі відпал.json&quot;]}}}}  </pre></p><p>--------------------- debugging info -----------------------------</p><script>let trace = 1, beforeTrace = 0; 

</script><script>//-  список доступних класів типів регістрів,
//-   що створюють відповідні елементи
//- {select:ClassElementSelect, number:ClassElementNumber, ...}
const myElementsRender = {};

</script><script> myElementsRender["ClassGeneralElement"] = class ClassGeneralElement {
  /**
   * Створює заготовку об'єкту загального типу
   * @param {Object} props
   * @property {string} props.id -  id елементу
   * @property {string} props.prefix - префікс для id елементу
   * @property {Object} props.reg  - типовий регістр з описом елементу
   * @property {Object} props.container - контейнер в якому потрібно розмістити елемент
   * @property {String} props.type - тип елементу (ключ в  myElementsRender)
   * @property {async Function} props.afterChange - зовнішня функція, що запускається після зміни значення
   */
  constructor(props = {}) {
    this.ln = props.ln ? props.ln : undefined;

    let trace = 0,
      ln = this.ln + "constructror()::";

    trace ? console.log(ln + "props=") : null;
    trace ? console.dir(props) : null;
    // -- батьківський контейнер для елементу -----
    if (!props.container) {
      console.error(ln + "Не вказано батьківський контейнер!!!");
    } else {
      this.container = props.container;
    }
    // -- id -----
    this.id = props.reg.id
      ? props.reg.id
      : "id" + new Date().getTime().toString().slice(-8);
    // -- префікс -----

    this.prefix = props.prefix ? props.prefix : this.id + "_";

    // -- регістр з загальним описом елементу

    this.reg = props.reg;

    // тип регистру

    this.type = props.reg.type;

    // дозвіл на зміну значення

    this.editable =
      props.reg.editable === undefined ? true : props.reg.editable;

    // зовнішня функція для обробки події зміни значення
    // запускається коли значення змінилося
    if (typeof props.afterChange === "function") {
      this.afterChange = props.afterChange;
    } else {
      this.afterChange = async (el = {}) => {
        let trace = 1,
          ln = el.ln + "afterChange()::";
        if (trace) {
          console.log(ln + `this.value=`);
          console.dir(this.value);
        }
        return 0;
      };
    }
  } //constructor

  /**
   * Додає до елементу класи, вказані в classList
   * @param {*} el - елемент до якого застосовуються класи
   * @param {Array | String} classList - масив класів або рядок з розділовими пробілами
   */

  setClassList(el, classList) {
    if (typeof classList === "string") {
      classList = classList.split(" ");
    }
    if (!Array.isArray(classList)) {
      console.error(
        "ClassGeneralElement.setClassList must be Array! classList=" +
          `${classList}`
      );
      return;
    }
    for (var i = 0; i < classList.length; i++) {
      el.classList.add(classList[i]);
    }
  } //setClassList

  /**
   * Додає до елементу атрибути, вказані в atributesList
   * @param {*} el - елемент до якого застосовуються атрибути
   * @param {Object} list - об'єкт з атрибутами елементу {enable:"true", ..}
   */
  setAtributes(el, list = {}) {
    if (typeof list != "object") {
      console.error(
        "ClassGeneralElement.setAttributes() must be Object! But list=" +
          `${list}`
      );
      return;
    }
    for (let key in list) {
      if (list.hasOwnProperty(key)) {
        el.setAttribute(key, list[key]);
      }
    }
  } //setAtributes
};
myElementsRender["ClassCreateElement"] = class ClassCreateElement extends (
  myElementsRender.ClassGeneralElement
) {
  /**
   * Створює налаштований DOM-елемент загального типу
   * @param {Object} props
   * @property {string} props.tag - тип елементу (number, range, select)
   * //@property {Function} props.onchange  - додаткова локальна функція обробки події
   * @property {Object} props.container - контейнер в якому потрібно розмістити елемент
   */
  constructor(props = {}) {
    props.ln = props.ln ? props.ln : "ClassCreateElement()::";
    super(props);

    let trace = 1,
      ln = this.ln + "constructror()::";
    trace ? console.log(ln + "props=") : null;
    trace ? console.dir(props) : null;

    // -- тег основного елемента, щоб створити шаблон
    this.tag = props.tag;

    // поточне значення
    this.value = props.reg.value;
    this.beforeValue = props.reg.value;
    // -- id - елементу DOM
    this.elId = this.prefix + "__" + this.id; //два підкреслення (щоб легко відділяти id регістру)
    // контейнер для всього елементу
    this.div = document.createElement("div");
    this.div.id = this.elId;
    this.div.classList.add("col");
    this.div.classList.add("form-group");

    // ---- <comment> --------
    this.comment = document.createElement("small");
    this.comment.innerHTML = this.reg.comment[lang];
    // ---- Field --------
    this.field = document.createElement(this.tag);
    this.field.classList.add("form-control");
    this.field.classList.add(this.prefix);
    this.field.classList.add("field");
    this.field.id = this.elId + "_field";
    if (typeof props.attributes == "object") {
      this.setAtributes(this.field, props.attributes);
    }
    if (typeof props.classes == "object") {
      this.setClassList(this.field, props.classes);
    }
    if (!this.editable) {
      this.field.classList.add("readonly");
    }
    // ---- <label=header> --------
    this.label = document.createElement("label");
    this.label.setAttribute("for", this.field.id);
    this.label.classList.add("h6");
    this.label.innerHTML = this.reg.header[lang];
    // ---- зв'язуємо разом ----------
    this.div.appendChild(this.label);
    this.div.appendChild(this.field);
    this.div.appendChild(this.comment);
    // -- поточне значення -----
    if (props.reg.value | (props.reg.value === 0)) {
      this.value = props.reg.value;
      this.beforeValue = props.reg.value;
      this.setValue(this.value);
    }
    // додаємо в контейнер елемент
    this.container.appendChild(this.div);
    // привязуємо this до обробника до this
    this.field.onchange = this.onchange.bind(this);
  }

  onchange(event) {
    let trace = 0;
    let ln = this.ln + "onchange()::";
    if (trace) {
      console.log(ln + "this=");
      console.dir(this);
    }
    trace ? console.log(ln + "this.field.value=" + this.field.value) : null;
  }

  // async _afterChange(parent) {
  //   await this.afterChange(parent);
  // }

  setValue(val) {
    let trace = 1,
      ln = this.ln + `setValue(${val})::`;
    trace
      ? console.log(
          ln +
            `Started:this.beforeValue=${this.beforeValue};this.value=${this.value}`
        )
      : null;
    trace = 1;
    this.value = val;
    this.beforeValue = this.value;
    trace
      ? console.log(
          ln +
            `Finished:this.beforeValue=${this.beforeValue};this.value=${this.value}`
        )
      : null;
    this.field.value = val;
    this.reg.value = val;
  }
  // /** встановлює атрибути елемента Field */
  // setProperties(el = "field", obj = {}) {
  //   //let el;

  //   console.log(this.ln + `setProperty[${key}]=${value}. Поки не реалізовано!`);
  // }

  getBeforeValue() {
    return this.beforeValue;
  }

  /**
   * @return true якщо елемент змінився
   */

  hasChanged() {
    let trace = 1,
      ln = this.ln + "hasChanged()::";

    let res;
    res =
      this.beforeValue == undefined
        ? true
        : this.field.value != this.beforeValue;
    trace
      ? console.log(
          ln +
            `this.beforeValue=${this.beforeValue};this.field.value=${this.field.value}; res=${res}`
        )
      : null;
    return res;
  }
  /** Повертає значення з DOM елементу field */
  getFieldValue() {
    return this.field.value;
  }
  getValue() {
    return this.value;
  }
};
// -----------  element: select -------------------
beforeTrace = trace;
trace = 1;

/**
 * Створює елемент вибору select
 * та заповнює його поля опціями вибору зі списку props.reg.regs
 * має функції setOption(val) та getOption
 */

myElementsRender["selectGeneral"] = class ClassElementSelect extends (
  myElementsRender.ClassCreateElement
) {
  /**
   * всі загальні поля беруться з батьківського конструктора
   * @param {*} props
   * @property {Function} props.getOption() - пост обробка функція викликається для обробки значення поля перед поверненням (наприклад для імені файла - можна додавати розширення .json)
   * @property {Function} props.setOption(val) - перед обробка функція викликається для обробки значення поля перед відображення в DOM (наприклад для імені файла - можна прибирати розширення .json)
   * @property {Object} props.reg.regs -  список варіантів вибору, типові регістри
   * @property {String | Number} props.reg.value - значення по замовчуванню
   */

  constructor(props = {}) {
    props.tag = "select";
    super(props);
    this.ln = "ClassElementSelectGeneral(" + props.reg.id + ")::";
    let trace = 1,
      ln = this.ln + "Constructor()::";
    if (trace) {
      console.log(ln + `props=`);
      console.dir(props);
    }
    // regs
    this.regs = props.regs ? props.regs : this.reg.regs;

    this.setOption = props.setOption
      ? props.setOption
      : (val) => {
          return val;
        };

    this.getOption = props.getOption
      ? props.getOption
      : (val) => {
          return val;
        };
    // промальовуємо список
    this.render();
    // -- початкова ініціалізація -----------
    // this.value = this.getFieldValue();
    trace ? console.log(ln + `this.value=${this.value}`) : null;

    if (trace) {
      console.log(ln + `this.getFieldValue()=${this.getFieldValue()}`);
      console.dir(this);
    }
  }

  async onchange(event) {
    let ln = this.ln + "onchange()::";
    let trace = 1;
    if (!this.hasChanged()) {
      return;
    }
    // this.children.remove();
    // this.render(this.regs[this.getFieldValue()]);
    this.setValue(this.getOption(this.getFieldValue()));

    await this.afterChange(this);

    super.onchange(event);
  }

  setValue(val) {
    let trace = 1,
      ln = this.ln + `setValue(${val})::`;
    trace ? console.log(ln + `Started`) : null;
    super.setValue(val);
  }

  render(regs = undefined) {
    let trace = 1,
      ln = this.ln + "render()::";
    trace ? console.log(ln + `Started::this.value=${this.value}`) : null;

    if (!regs) {
      // якщо список не вказано то приймаємо поточне значення
      regs = this.regs;
    } else {
      if (typeof regs === "object") {
        // знищуємо всіх дітей
        this.field.innerHTML = "";
        this.regs = undefined;
        // створюємо нових
        this.regs = regs;
      } else {
        console.error(ln + "regs must be an Object");
        return;
      }
    }

    // створюємо список <option>
    let keys = "";
    let first = true;
    let currKey = "";
    let firstKey = "";

    // якщо  regs - Об'єкт
    if (typeof this.regs == "object" && !Array.isArray(this.regs)) {
      for (let key in this.regs) {
        let trace = 0;
        if (this.regs.hasOwnProperty(key)) {
          let selected = "";
          // якщо this.value не вказано, то перший елемент в списку опцій обирається автоматично браузером
          if (!first && key == this.value) {
            selected = "selected";
            currKey = key;
          }
          trace ? console.log(ln + "key=" + key) : null;
          // перший елемент не записуємо, а запамятовуємо, щоб зробити його selected
          // якщо не вибрано інший елемент
          if (first) {
            firstKey = key;
            first = false;
            continue;
          }

          let option = (keys += `<option value='${this.setOption(
            key
          )}' ${selected}> ${this.regs[key].header[lang]} </option>\n`);
        }
      } //for
      // -- активуємо перший варіант, якщо не обрано іншого
      let selected = currKey === "" ? "selected" : "";
      // додаємо перший варіант
      keys =
        `<option value='${this.setOption(firstKey)}' ${selected}> ${
          this.regs[firstKey].header[lang]
        } </option>\n` + keys;
    } // if (typeof this.regs == "object")

    // якщо  regs - Масив
    if (Array.isArray(this.regs)) {
      let trace = 1;

      for (let i = 0; i < this.regs.length; i++) {
        const key = this.regs[i];
        let selected = "";
        // якщо this.value не вказано, то перший елемент в списку опцій обирається автоматично браузером
        if (!first && key == this.value) {
          selected = "selected";
          currKey = key;
          trace ? console.log(ln + `Selected: key=${key}`) : null;
        }
        // перший елемент не записуємо, а запамятовуємо, щоб зробити його selected
        // якщо не вибрано інший елемент
        if (first) {
          firstKey = key;
          first = false;
          continue;
        }
        let opt = `<option value='${key}' ${selected}> ${this.setOption(
          key
        )} </option>\n`;
        trace ? console.log(ln + "opt=" + opt) : null;
        keys += opt;
      }
      // -- активуємо перший варіант, якщо не обрано іншого
      let selected = currKey === "" ? "selected" : "";

      // додаємо перший варіант
      keys =
        `<option value='${firstKey}' ${selected} > ${this.setOption(
          firstKey
        )} </option>\n` + keys;
    } //if (Array.isArray

    // -- опції вибору -------
    this.field.innerHTML = keys;

    // -- даємо час щоби створити елементи

    setTimeout(() => {
      // оновлюємо поточне значення
      let trace = 1,
        ln = this.ln + "setTimeOut()::";

      let val = this.getFieldValue();
      trace
        ? console.log(
            ln + `----- Started! this.id=${this.id}; field.value = ${val}`
          )
        : null;
      this.setValue(val);
    }, 500);
  }
};

trace = beforeTrace;
// -----------  element: select -------------------
beforeTrace = trace;
trace = 1;

/**
 * Створює елемент вибору select
 *
 */
myElementsRender["select"] = class ClassElementSelectRegsList extends (
  myElementsRender.selectGeneral
) {
  constructor(props = {}) {
    super(props);
    this.ln = "ClassElementSelectRegsList(" + props.reg.id + ")::";
    let trace = 0,
      ln = this.ln + "Constructor()::";

    // create children
    this.children = new tasks.ClassRegsList({
      container: this.container,
      prefix: this.elId,
      regs: this.regs[this.value].regs,
      types: this.types,
    });

    // рендерим
    this.setValue(this.value);

    if (trace) {
      console.log(ln + `this.getFieldValue()=${this.getFieldValue()}`);
      console.dir(this);
    }
  }

  onchange(event) {
    let ln = this.ln + "onchange()::elem_select()::";
    let trace = 1;
    if (!this.hasChanged()) {
      return;
    }
    this.setValue(this.getFieldValue());
    super.onchange(event);
  }

  setValue(val) {
    let trace = 1,
      ln = this.ln + `setValue(${val})::`;
    trace ? console.log(ln + `Started`) : null;
    super.setValue(val);
    this.children.remove();
    this.children.render(this.regs[val].regs);
  }
};

trace = beforeTrace;
// -----------  element: input type="number" -------------------
beforeTrace = trace;
trace = 0;
/**
 * Створює та повертає елемент вводу числа
 * має min та max
 */
myElementsRender["number"] = class ClassElementNumber extends (
  myElementsRender.ClassCreateElement
) {
  constructor(props = {}) {
    props.tag = "input";
    super(props);
    this.ln = "ClassElementNumber(" + props.reg.id + ")::";
    let trace = 0,
      ln = this.ln + "Constructor()::";

    // -- тип поля Number -------
    this.field.setAttribute("type", "number");

    // -- обробник зміни значення поля ----------
    // this.field.onchange = this.onchange.bind(this);

    if (props.reg.min | (props.reg.min === 0)) {
      this.field.setAttribute("min", props.reg.min);
      this.min = props.reg.min;
    }

    if (props.reg.max | (props.reg.max === 0)) {
      this.field.setAttribute("max", props.reg.max);
      this.max = props.reg.max;
    }

    this.field.setAttribute("value", props.reg.value);

    if (trace) {
      console.log(ln + "this=");
      console.dir(this);
    }
  }
  onchange(event) {
    let trace = 0,
      ln = this.ln + "onchange()::";
    super.onchange(event);
    let val = this.getFieldValue();
    this.setValue(val);
    //this.field.value = this.value;
  } // onchange()

  setValue(val) {
    if (val > this.max) {
      console.error(
        this.ln +
          `Can't set ${val}, because max=${this.max}. Was setted max value!`
      );
      val = this.max;
    }
    if (val < this.min) {
      val = this.min;
      console.error(
        this.ln +
          `Can't set ${val}, because min=${this.min}. Was setted min value!`
      );
    }
    super.setValue(val);
  }
}; // class

trace = beforeTrace;
// -----------  element: select -------------------
beforeTrace = trace;
trace = 1;

/**
 * Створює елемент для вводу часу
 *
 */

//

myElementsRender["timer"] = class ClassElementTimer extends (
  myElementsRender.ClassCreateElement
) {
  constructor(props = {}) {
    props.tag = "input";
    super(props);
    this.ln = "ClassElementTimer(" + props.reg.id + ")::";
    let trace = 1,
      ln = this.ln + "Constructor()::";

    // -- тип поля  -------
    this.field.setAttribute("type", "time");

    // хв, мінімальне значення
    this.min = 0;
    if (props.reg.min || props.reg.min === 0) {
      this.min = props.reg.min;
    }
    this.field.setAttribute("min", this.minutesToString(this.min));

    // хв, максимальне значення
    this.max = 99 * 60; //99 годин
    if (props.reg.max | (props.reg.max === 0)) {
      this.max = props.reg.max;
    }
    this.field.setAttribute("max", this.minutesToString(this.max));

    // встановлюємо значення поля
    this.field.value = this.minutesToString(this.value);

    if (trace) {
      console.log(ln + "this=");
      console.dir(this);
    }
  }
  onchange(event) {
    let trace = 1,
      ln = this.ln + "onchange()::";
    super.onchange(event);
    let val = this.getFieldValue();
    this.setValue(this.stringToMinutes(val));
    //this.field.value = this.value;
  } // onchange()

  /**
   * Вираховує кількість хвилин в hhmm
   * @param {String} hhmm - час в форматі "00:00"
   */
  stringToMinutes(hhmm = "00:00") {
    let ln = this.ln + `stringToMinutes(${hhmm})::`;
    let arr = hhmm.split(":");
    if (arr.length > 2) {
      throw Error(ln + `Невірний формат аргументу`);
    }
    let val = parseInt(arr[0]) * 60 + parseInt(arr[1]);
    return val;
  }

  minutesToString(minutes) {
    let time = new Date(minutes * 60 * 1000).toISOString();
    //console.log(time);
    return time.slice(11, -8);
  }

  setValue(val) {
    if (val > this.max) {
      console.error(
        this.ln +
          `Can't set ${val}, because max=${this.max}. Was setted max value!`
      );
      val = this.max;
    }
    if (val < this.min) {
      val = this.min;
      console.error(
        this.ln +
          `Can't set ${val}, because min=${this.min}. Was setted min value!`
      );
    }
    super.setValue(val);
    this.field.value = this.minutesToString(val);
  }
}; // class
console.log("Element type : timer loaded");
trace = beforeTrace;
// -----------  element: textarea;  file: myElR_textarea  -------------------
beforeTrace = trace;
trace = 1;
/**
 * Створює та повертає елемент багаторядкового тексту
 *
 */
myElementsRender["textarea"] = class ClassElementNumber extends (
  myElementsRender.ClassCreateElement
) {
  constructor(props = {}) {
    props.tag = "textarea";
    super(props);
    this.ln = "ClassElementTextArea(" + props.reg.id + ")::";
    let trace = 1,
      ln = this.ln + "Constructor()::";

    // -- тип поля Number -------
    this.field.setAttribute("rows", "3");

    // -- обробник зміни значення поля ----------
    // 2024-01-31 перенесено в батьківський клас
    // this.field.onchange = this.onchange.bind(this);

    this.field.setAttribute("value", props.reg.value);
    if (trace) {
      console.log(ln + "this=");
      console.dir(this);
    }
  }
  onchange(event) {
    let trace = 1,
      ln = this.ln + "onchange()::";
    super.onchange(event);
    let val = this.getFieldValue();
    this.setValue(val);
    //this.field.value = this.value;
  } // onchange()

  // setValue(val) {
  //   if (val > this.max) {
  //     console.error(
  //       this.ln +
  //         `Can't set ${val}, because max=${this.max}. Was setted max value!`
  //     );
  //     val = this.max;
  //   }
  //   if (val < this.min) {
  //     val = this.min;
  //     console.error(
  //       this.ln +
  //         `Can't set ${val}, because min=${this.min}. Was setted min value!`
  //     );
  //   }
  //   super.setValue(val);
  // }
}; // class

trace = beforeTrace;
// -----------  element: select -------------------
beforeTrace = trace;
trace = 1;
/**
 * Створює та повертає елемент вибору
 *
 */
myElementsRender["text"] = class ClassElementNumber extends (
  myElementsRender.ClassCreateElement
) {
  constructor(props = {}) {
    props.tag = "input";
    super(props);
    this.ln = "ClassElementTextArea(" + props.reg.id + ")::";
    let trace = 1,
      ln = this.ln + "Constructor()::";

    // -- тип поля Number -------
    this.field.setAttribute("type", "text");
    this.field.setAttribute("maxlength", "20");
    this.field.setAttribute("size", "22");

    // -- обробник зміни значення поля ----------
    // 2024-01-31 перенесено в батьківський клас
    // this.field.onchange = this.onchange.bind(this);

    this.field.setAttribute("value", props.reg.value);
    if (trace) {
      console.log(ln + "this=");
      console.dir(this);
    }
  }
  onchange(event) {
    let trace = 1,
      ln = this.ln + "onchange()::";
    super.onchange(event);
    let val = this.getFieldValue();
    this.setValue(val);
    //this.field.value = this.value;
  } // onchange()

  // setValue(val) {
  //   if (val > this.max) {
  //     console.error(
  //       this.ln +
  //         `Can't set ${val}, because max=${this.max}. Was setted max value!`
  //     );
  //     val = this.max;
  //   }
  //   if (val < this.min) {
  //     val = this.min;
  //     console.error(
  //       this.ln +
  //         `Can't set ${val}, because min=${this.min}. Was setted min value!`
  //     );
  //   }
  //   super.setValue(val);
  // }
}; // class

trace = beforeTrace;
// -----------  element: regsList -------------------
beforeTrace = trace;
trace = 1;
/**
 * Створює та повертає колекцію об'єктів регістрів та їх DOM - елементи
 *
 */

myElementsRender["regsList"] = class ClassRegsList {
  /**
   * Створює контейнер з регістрами
   * @param {*} props
   * @property {DOMnode} props.container - DOM контенер в якому буде розміщено
   * @property {String} props.prefix - префікс до id
   * @property {Object} props.regs - список регістрів
   * @property {Object} props.types - список доступних класів, що рендерять елементи
   */

  constructor(props = {}) {
    this.ln = `ClassRegsList(${props.prefix})::`;
    let trace = 0,
      ln = this.ln + "сonstructor()::";
    //
    if (trace) {
      console.log(ln + `props=`);
      console.dir(props);
    }

    // об'єкт, що містить в собі список доступних типів (класів) регістрів,
    // що використовуються для їх створення

    this.types = myElementsRender;

    // список регістрів
    if (!props.regs) {
      props.regs = {};
      throw new Error(ln + "'props.regs' not defined !!");
    }

    // prefix
    this.prefix = props.prefix ? props.prefix : "undefined_";

    // контейнер DOM, в якому буде розміщено елемент
    if (!props.container) {
      props.container = document.body;
      throw new Error(
        ln + "'props.container' not defined !! Was selected 'document.body' "
      );
    }
    this.container = props.container;

    // список дітей, елементу

    this.children = {};

    // -- початкова ініціалізація -----------
    this.render(props.regs);

    if (trace) {
      console.log(ln + `Was created element. this=${""}`);
      console.dir(this);
    }
  }

  onchange(event) {}

  remove() {
    let trace = 0,
      ln = this.ln + `remove(${this.prefix})::`;
    let regs = this.children;
    for (let key in regs) {
      let lln = ln + `child[${key}]::`;
      trace ? console.log(ln + `key=${key}`) : null;
      if (regs.hasOwnProperty(key)) {
        let child = regs[key];

        let el = document.getElementById(child.div.id);
        if (el) {
          el.remove();
        }
        trace
          ? console.log(
              lln + `Was removed element from DOM id= ${child.div.id} )`
            )
          : null;
        regs[key] = undefined;
      } //if (regs.hasOwnProperty(key))
    } //for
    this.children = {};
    console.log(ln + "Completed!");
  }

  render(regs) {
    let trace = 0,
      ln = this.ln + `render(${this.prefix})::`;
    trace ? console.log(ln + `Started`) : null;
    trace ? console.log(ln + `regs=${regs}`) : null;
    this.children = {};
    for (let key in regs) {
      trace ? console.log(ln + `key=${key}`) : null;
      if (regs.hasOwnProperty(key)) {
        let trace = 1;
        let item = regs[key];
        trace
          ? console.log(
              ln +
                `for (key=${key}) item.id= ${item.id}; item.type=${item.type} )`
            )
          : null;

        if (this.types[item.type]) {
          // тип регістру визначений, визиваємо його конструктор
          let el = new this.types[item.type]({
            prefix: this.prefix,
            reg: item,
            container: this.container,
          });
          // перевіряємо чи є елемент з таким id в DOM
          if (document.getElementById(el.idEl)) {
            throw Error(
              ln + `DOM element with id = ${el.idEl} already presented!!`
            );
          }
          // додаємо в дерево DOM
          this.container.appendChild(el.div);
          // запамятовуємо в списку дітей
          this.children[el.id] = el;
          trace
            ? console.log(ln + `Created element DOM id= ${el.elId} )`)
            : null;
        } else {
          console.error(
            ln +
              `Not found in tasks.elementsTypes(=this.types) type: item.type=${item.type}`
          );
        } //if
      } //if (regs.hasOwnProperty(key))
    } // for
    trace
      ? console.log(ln + `Created this.children=${Object.keys(this.children)}`)
      : null;
  } //renderRegs()

  /**
   * Збирає значення регістрів всіх дітей
   * @returns {Object} {reg1.id:reg1.value, reg2.id:reg2.value, } for example {'tT':500,'o':15,..}
   */
  getValues() {
    let trace = 0,
      ln = this.ln + ` getValues(${this.prefix})::`;
    let children = this.children;
    let res = {};
    for (let key in children) {
      if (children.hasOwnProperty(key)) {
        let lln = ln + `for (${key})::`,
          trace = 0;
        let child = children[key];
        if (trace) {
          console.log(lln + `child=`);
          console.dir(child);
        }
        res[child.id] = child.value;
        if (child.children) {
          let resChild = child.children.getValues();
          Object.assign(res, resChild);
        }
      }
    }
    //trace = 1;
    if (trace) {
      console.log(ln + `Response=`);
      console.dir(res);
    }
    return res;
  } //getValues()

  // /**
  //  *
  //  * @param {Object} values - {'tT':500,...} or {'tT':{value:500,enable:true,...},...}
  //  */

  setRegister(id, value) {
    let trace = 0,
      ln = this.ln + `setRegister(${id};${value})::`;
    trace ? console.log(ln + `Started`) : null;
    let reg = this.findRegister(id);
    if (reg) {
      // регістр знайдено
      if (typeof value != "object") {
        reg.setValue(value);
        return value;
      }
      // якщо value - об'экт зі значеннями, то перебираємо ці значення
      for (let key in value) {
        if (value.hasOwnProperty(key)) {
          if (reg[key]) {
            // поле key  в регістрі знайдено
            reg[key].setProperty(key, value[key]);
          }
        } //for
      }
    } // setRegister(id,values)
  }

  /**
   * Знаходить серед дітей регістр з вказаним id
   * @param {String} id
   * @return {undefined | Object }
   */
  findRegister(id) {
    let trace = 0,
      ln = this.ln + `findRegister(${id}})::`;
    trace ? console.log(ln + `Started`) : null;

    let res = this.children[id];

    if (!res) {
      // якщо при прямому пошуку не знайдено
      // шукаємо в регістрах з дітьми
      for (let key in this.children) {
        if (this.children.hasOwnProperty(key)) {
          if (this.children[key].children) {
            res = this.children[key].children.findRegister(id);
            if (res) {
              break;
            }
          }
        }
      } //for
    }
    return res;
  }
}; // Class

trace = beforeTrace;
// ------- myElR_button.js -----------------------------------
beforeTrace = trace;
trace = 1;
/** Створює та повертає елемент button
 *
 */

myElementsRender["button"] = class ClassButton extends (
  myElementsRender.ClassGeneralElement
) {
  /**
   * Створює DOM елемент кнопки та зберігає в this.el
   * @param {*} props
   *
   */
  constructor(props = {}) {
    props.ln = props.ln ? props.ln : `ClassButton(${props.reg.id})::`;

    super(props);

    let trace = 1,
      ln = this.ln + "ClassButton::constructor::";

    if (trace) {
      console.log(ln + `props=`);
      console.dir(props);
    }

    this.parent = props.parent;
    // створюємо елемент ДОМ
    let but = document.createElement("button");
    but.id =
      parent.id + this.id
        ? this.id
        : console.error(this.ln + "Id of button not defined!");
    // оформлюємо кнопку
    but.classList.add("btn");
    if (props.reg.classes) {
      this.setClassList(but, props.reg.classes);
    }
    if (props.reg.attributes) {
      this.setAtributes(but, props.reg.attributes);
    }
    //  напис на кнопці
    but.setAttribute("type", "button");
    but.innerHTML = props.reg.header[lang]
      ? props.reg.header[lang]
      : "<h6>???</h6>";
    // обробник кліку
    but.onclick = props.reg.onclick
      ? props.reg.onclick.bind(this)
      : this.onclick;
    // зберігаємо кнопку
    this.el = but;
    this.container.appendChild(but);
  } // constructor
  onclick(event) {
    let trace = 1,
      ln = `${this.el.id}::Was pressed!! External event listener not defined!   `;
    trace ? console.log(ln) : null;
  }
};
// ------- myElR_buttonGroup.js -----------------------------------
beforeTrace = trace;
trace = 1;
/** Створює та повертає елемент buttonGroupe
 *
 */
myElementsRender["buttonGroup"] = class ClassButtonGroup extends (
  myElementsRender.ClassGeneralElement
) {
  constructor(props = {}) {
    props.ln = props.ln ? props.ln : `buttonGroup()::`;
    super(props);
    let trace = 1,
      ln = this.ln + "Constructor()::";
    if (trace) {
      console.log(ln + `props=`);
      console.dir(props);
    }
    // список типів для рендерингу елементів
    this.types = props.types
      ? props.types
      : console.error(this.ln + " types is not defined! ");
    // створюємо группу кнопок
    let btnGroup = document.createElement("div");
    // налаштовуємо класи
    if (this.reg.classes) {
      this.setClassList(btnGroup, this.reg.classes);
    } else {
      this.setClassList(btnGroup, "col btn-group-vertical");
    }
    btnGroup.setAttribute("role", "group");
    // налаштовуємо атрибути, якщо вони є
    if (this.reg.attributes) {
      this.setAttributes(btnGroup, this.attributes);
    }
    this.btnGroup = btnGroup;
    // створюємо кнопки
    this.children = {};
    for (let key in this.reg.regs) {
      if (this.reg.regs.hasOwnProperty(key)) {
        let trace = 1,
          ln = this.ln + `CreateButton(${key})::`;
        let btn = {};
        btn.reg = this.reg.regs[key];
        btn.reg.id = this.id + "_" + key;
        //btn.ln = ln;
        btn.container = this.btnGroup;
        btn.parent = this;
        if (trace) {
          console.log(ln + `btn=`);
          console.dir(btn);
        }
        this.children[key] = new this.types["button"](btn);
      }
    }
    this.el = btnGroup;
    this.container.appendChild(this.el);
    if (trace) {
      console.log(ln + `this=`);
      console.dir(this);
    }
  } // costructor
};
</script><div class="container-fluide"><div class="row"><div class="col-2 border"><div class="container-fluide" id="fileManagerContainer"><p>--------------------- debugging info manager = -----------------------------<pre>manager.fileManager={&quot;homeDir&quot;:&quot;F:\\node\\ASUTP2021\\controllers\\tasksController\\tests\\tasks&quot;,&quot;ln&quot;:&quot;ClassTasksManager::ClassFileManager::&quot;,&quot;homeURL&quot;:&quot;/fileManager/&quot;,&quot;filesList&quot;:[&quot;default.json&quot;,&quot;task01.json&quot;,&quot;колесаВеликі відпал.json&quot;],&quot;reg&quot;:{&quot;id&quot;:&quot;tasksList&quot;,&quot;ln&quot;:&quot;ClassReg_regsList(tasksList)::&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;Робота зі списком завдань&quot;,&quot;en&quot;:&quot;Working with list of tasks&quot;,&quot;ru&quot;:&quot;Работа со списком заданий&quot;},&quot;type&quot;:&quot;regsList&quot;,&quot;comment&quot;:{&quot;ua&quot;:&quot;&quot;,&quot;en&quot;:&quot;&quot;,&quot;ru&quot;:&quot;&quot;},&quot;editable&quot;:true,&quot;regs&quot;:{&quot;fileNames&quot;:{&quot;id&quot;:&quot;fileNames&quot;,&quot;ln&quot;:&quot;ClassRegister(fileNames)::&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;Перелік програм&quot;,&quot;en&quot;:&quot;The list of programs&quot;,&quot;ru&quot;:&quot;Список программ&quot;},&quot;type&quot;:&quot;simpleSelect&quot;,&quot;comment&quot;:{&quot;ua&quot;:&quot;Виберіть програму&quot;,&quot;en&quot;:&quot;Select program&quot;,&quot;ru&quot;:&quot;Выберите програму&quot;},&quot;editable&quot;:true,&quot;list&quot;:[&quot;default.json&quot;,&quot;task01.json&quot;,&quot;колесаВеликі відпал.json&quot;]}}}}  </pre></p><p>--------------------- debugging info -----------------------------</p><div class="row" id="el_fileMan_btnGroup"></div><div class="row" id="el_fileMan_listFiles"></div><script>const ClassFileManager = class FileManager {
  /**
   *
   * @param {Object} props - список параметрів
   *
   */

  constructor(props) {
    this.ln = `ClassFileManager(${props.id})::`;
    let trace = 1,
      ln = this.ln + "constructor()::";
    if (trace) {
      console.log(ln + `props=`);
      console.dir(props);
    }
    this.id = props.id;
    // list of types
    this.types = props.types;

    // container
    this.container = props.container
      ? props.container
      : console.error(this.ln + "Container not defined!");

    // list of buttons
    this.buttons = {};
    if (props.buttons) {
      props.buttons.types = this.types;
      this.buttons = new this.types["buttonGroup"](props.buttons);
    }
    // listFiles
    this.filesList = new this.types["selectGeneral"](props.filesList);

    this.getFilesList = props.getFilesList
      ? props.getFilesList
      : () => {
          console.log(this.ln + "Function getListFiles() not defined");
          return [];
        };
  } //constructor
  renderFilesList(regs) {
    // промальовує елемент
    this.filesList.render(regs);
  }
  getFilesListValue() {}
};
//- парсимо отримані з сервера дані, та зберігаємо їх в fileManager
//let fileManager= JSON.parse( '!{JSON.stringify(manager.fileManager.reg)}' );
// передаємо контейнер в якому буде побудований менеджер файлів
let props = {};
props.container = document.getElementById("fileManagerContainer");
props.types = myElementsRender;
props.id = "fileManager";
//- props.reg ={
//-   id:"fileManager",
//-   header:{ua:"",en:"",ry:""},
//-   ln:"tasks_fileManager.js::"
//- }
props.buttons = {
  container: document.getElementById("el_fileMan_btnGroup"),
  reg: {
    id: props.id + "_btnGroup",
    header: { ua: "", en: "", ru: "" },
    type: "buttonGroup",
    regs: {},
  },
};

props.buttons.reg.regs.btnSave = {
  classes: ["btn-primary"],
  header: { ua: "Зберегти", en: "Save", ru: "Сохранить" },
  onclick: function (e) {
    let trace = 1,
      ln = "btnAccept::onClick::";
    trace ? console.log(ln + ` Pressed!`) : null;
    let data = tasks.model.getValues();
    if (
      !confirm(
        {
          ua: `Ви дійсно бажаєте зберегти програму "${data[0].name}"?`,
          en: `Do You really want to save the program  "${data[0].name}"?`,
          ru: `Вы действительно хотите сохранить программу "${data[0].name}"?`,
        }[lang]
      )
    ) {
      console.log(ln + "Cancelled by user.");
      return;
    }
  },
};

props.buttons.reg.regs.btnAccept = {
  classes: ["btn-success"],
  header: { ua: "Застосувати", en: "Accept", ru: "Применить" },
  onclick: async function (e) {
    let trace = 1,
      ln = "btnAccept::onClick::";
    trace ? console.log(ln + ` Pressed!`) : null;
    let data = tasks.model.getValues();
    if (
      !confirm(
        {
          ua: `Ви дійсно бажаєте завантажити програму "${data[0].name}"?`,
          en: `Do You really want to load program  "${data[0].name}"?`,
          ru: `Вы действительно хотите загрузить программу "${data[0].name}"?`,
        }[lang]
      )
    ) {
      console.log(ln + "Cancelled by user.");
      return;
    }

    if (trace) {
      console.log(ln + `data=`);
      console.dir(data);
    }
  }, // onclick
};

props.buttons.reg.regs.btnDelete = {
  classes: ["btn-warning"],
  header: { ua: "Видалити", en: "Delete", ru: "Удалить" },
  onclick: function (e) {
    let trace = 1,
      ln = "btnDelete::onClick::";
    trace ? console.log(ln + ` Pressed!`) : null;
    if (trace) {
      console.log(ln + `this=`);
      console.dir(this);
    }
    let data = fileManager.filesList.getValue(); //tasks.model.getValues();
    if (
      !confirm(
        {
          ua: `Ви дійсно бажаєте видалити програму "${data}"?`,
          en: `Do You really want to delete the program  "${data}"?`,
          ru: `Вы действительно хотите удалить программу "${data}"?`,
        }[lang]
      )
    ) {
      console.log(ln + "Cancelled by user.");
      return;
    }
  }, //oclick,
};

props.filesList = {
  container: document.getElementById("el_fileMan_listFiles"),
  attributes: { size: 10 },
  reg: {
    prefix: props.id,
    id: "fileList",
    value: "task01.json",
    header: {
      ua: `Список програм`,
      en: `The list of program`,
      ru: `Список программ`,
    },
    comment: {
      ua: `Виберіть програму`,
      en: `Select a program`,
      ru: `Выберите программу`,
    },
    type: "selectGeneral",
    regs: ["Пусто", "Prg1"],
  },
  setOption: (val) => {
    return val.split(".")[0];
  },
  // непотрібна так як в value елемента зберігається імя файла повністю
  // getOption: (val) => {
  //   return "" + val + ".json";
  // },
};

const fileManager = new ClassFileManager(props);
</script><script>//fileManager.filesList.reg.regs = ;
fileManager.renderFilesList(JSON.parse(  '["default.json","task01.json","колесаВеликі відпал.json"]' ))</script></div></div><div class="col"><div class="container-fluide" id="tasksContainer"></div></div></div></div><script>const tasks={};


tasks.header = JSON.parse(  '{"ua":"Створення програми","en":"Program creating","ru":"Создание программы"}' );
tasks.id=JSON.parse(  '"TasksManager"' );
tasks.reg = JSON.parse(  '{"id":"taskType","ln":"ClassReg_select(taskType)::","header":{"ua":"Тип кроку","en":"Select type of step","ru":"Тип шага"},"type":"select","comment":{"ua":"Доступні типи","en":"Avaliable types","ru":"Доступные типы"},"editable":true,"regs":{"description":{"id":"description","ln":"ClassReg_regsList(description)::","header":{"ua":"Загальна інформація","en":"General descriptiom of program","ru":"Общее описание програмы"},"type":"regsList","comment":{"ua":"","en":"","ru":""},"editable":false,"regs":{"name":{"id":"name","ln":"tasks.description.name::","header":{"ua":"Назва програми","en":"Program name","ru":"Наименование программы"},"type":"text","value":"empty","comment":{"ua":"3..20 символів","en":"3..20 characters","ru":"3..20 символов"},"editable":true},"note":{"id":"note","ln":"tasks.description.note::","header":{"ua":"Примітки","en":"Notes","ru":"Примечания"},"type":"textarea","value":"empty","comment":{"ua":"Опис програми","en":"Program description","ru":"Описание программы"},"editable":true}}},"ClassTask_Heating":{"id":"ClassTask_Heating","ln":"ClassTaskThermal()::","header":{"ua":"Нагрівання","en":"Heating","ru":"Нагревание"},"type":"regsList","comment":{"ua":"Немає опису","en":"Note not defined","ru":"Описания нет"},"editable":true,"regs":{"tT":{"id":"tT","ln":"ClassReg_number(tT)::","header":{"ua":"T,°C","en":"T,°C","ru":"T,°C"},"type":"number","value":0,"comment":{"ua":"Цільова температура","en":"Task temperature","ru":"Целевая температура"},"editable":true,"min":0,"max":150},"errTmin":{"id":"errTmin","ln":"ClassReg_number(errTmin)::","header":{"ua":"errTmin,°C","en":"errTmin,°C","ru":"errTmin,°C"},"type":"number","value":0,"comment":{"ua":"Макс. відх. вниз (0=вимкн)","en":"Limit of low temperature (0=disable)","ru":"Макс. откл. вниз (0=выкл)"},"editable":true,"min":-100,"max":0},"errTmax":{"id":"errTmax","ln":"ClassReg_number(errTmax)::","header":{"ua":"errTmax,°C","en":"errTmax,°C","ru":"errTmax,°C"},"type":"number","value":0,"comment":{"ua":"Макс. відх. вверх (0=вимкн)","en":"Limit of high temperature (0=disable)","ru":"Макс. откл. вверх (0=выкл)"},"editable":true,"min":0,"max":100},"regMode":{"id":"regMode","ln":"ClassReg_select(regMode)::","header":{"ua":"Регулювання","en":"Regulation","ru":"Регулирование"},"type":"select","value":"pid","comment":{"ua":"Закон регулювання","en":"Control type","ru":"Закон регулирования"},"editable":true,"regs":{"pos":{"id":"pos","ln":"ClassReg_regsList(pos)::","header":{"ua":"Позиційний","en":"Positional","ru":"Позиционный"},"type":"regsList","comment":{"ua":"Позиційний закон регулювання","en":"Positional regulation","ru":"Позиционный закон регуллирования"},"editable":true,"regs":{"o":{"id":"o","ln":"ClassReg_number(o)::","header":{"ua":"Неузгодження","en":"Difference","ru":"Рассогласование"},"type":"number","value":-2,"comment":{"ua":"Неузгодження температур,°С","en":"Temperature difference,°С","ru":"Рассогласование температур,°С"},"editable":true,"min":-20,"max":0}}},"pid":{"id":"pid","ln":"ClassReg_regsList(pid)::","header":{"ua":"ПІД","en":"PID","ru":"ПИД"},"type":"regsList","comment":{"ua":"ПІД закон регулювання","en":"PID regulation","ru":"ПИД закон регуллирования"},"editable":true,"regs":{"o":{"id":"o","ln":"ClassReg_number(o)::","header":{"ua":"П","en":"P","ru":"П"},"type":"number","value":5,"comment":{"ua":"Пропорційна складова","en":"Proportional gain","ru":"Пропорциональная составляющая"},"editable":true,"min":0,"max":100},"ti":{"id":"ti","ln":"ClassReg_number(ti)::","header":{"ua":"І","en":"I","ru":"И"},"type":"number","value":5,"comment":{"ua":"Інтегральна складова","en":"Integral gain","ru":"Интегральная составляющая"},"editable":true,"min":0,"max":100},"td":{"id":"td","ln":"ClassReg_number(td)::","header":{"ua":"Д","en":"D","ru":"Д"},"type":"number","value":5,"comment":{"ua":"Диференційна складова","en":"Differencial gain","ru":"Диферинциальная составляющая"},"editable":true,"min":0,"max":100}}}}},"wT":{"id":"wT","ln":"ClassReg_number(wT)::","header":{"ua":"wT,°C","en":"wT,°C","ru":"wT,°C"},"type":"number","value":0,"comment":{"ua":"Початок ПІД рег. (=0 вимкн.)","en":"Start PID regulation (=0 off)","ru":"Начало ПИД рег. (=0-выкл.)"},"editable":true,"min":-200,"max":0},"H":{"id":"H","ln":"ClassReg_timer(H)::","header":{"ua":"Нагрівання","en":"Heating","ru":"Нагревание"},"type":"timer","value":0,"comment":{"ua":"Час нагрівання (=0 - макс. швидко)","en":"Heating time (=0 quick)","ru":"Время нагревания (=0 макс. быстро)"},"editable":true,"min":0,"max":1439}}}}}' );
tasks.list = JSON.parse(  '[{"id":"description","name":"prg01","note":"Короткий опис програми"},{"id":"ClassTask_Heating","tT":0,"errTmin":-15,"errTmax":15,"regMode":"pid","o":0,"ti":0,"td":0,"wT":0,"H":0}]' );
tasks.container = document.getElementById( 'tasksContainer' );

</script><script>// додано для сумісності з попереднім кодом
tasks.elementsTypes = myElementsRender;
tasks.ClassRegsList = myElementsRender.regsList;

</script><script> // аналог list, але в ньому зберігаються всі створені js-об'єкти регістрів
// для швидкого доступу
tasks.model = {};
tasks.model.data = [];

tasks.model.renumber = (array, start = 1) => {
  if (!array) {
    array = tasks.model.data;
  }
  if (start < 1) {
    start = 1;
  }
  for (let i = start; i < array.length; i++) {
    const element = array[i];
    if (Array.isArray(element)) {
      // TODO це масив підкроків
      let msg = ln + "Паралельні кроки поки не підтримуються !!";
      console.error(msg);
      throw new Error(msg);
    }
    if (typeof element == "object" && element.hasOwnProperty("stepNumber")) {
      element.renumber(i);
    }
  }
}; //tasks.model.renumber

tasks.model.deleteStep = (stepNumber) => {
  stepNumber = parseInt(stepNumber);
  let model = tasks.model;
  console.log("======model======");
  console.dir(model);
  if (!stepNumber || stepNumber === 0 || stepNumber > model.data.length - 1) {
    throw new Error(`Uncompatible stepNumber=${stepNumber} ! `);
    return;
  }
  let stepString = ("00" + stepNumber).slice(-2);
  let trace = 1,
    ln = `tasks.model.deleteStep(${stepString})::`;
  trace ? console.log(ln + `Started!`) : null;

  if (model.data.length <= 2) {
    alert(
      {
        ua: `Не можливо видалити останній крок  ${stepString}!`,
        en: `You can't delete the last step  ${stepString}!`,
        ru: `Невозмозно удалить последний шаг ${stepString}!`,
      }[lang]
    );
    throw new Error(ln + `Last step can't be deleted ! `);
    return;
  }
  if (
    !confirm(
      {
        ua: `Ви дійсно бажаєте видалити крок № ${stepString}?`,
        en: `Are You really want to delete step № ${stepString}?`,
        ru: `Вы действительно хотите удалить шаг № ${stepString}?`,
      }[lang]
    )
  ) {
    console.log(ln + "Cancelled by user.");
    return;
  }
  // find element
  let el = model.data[stepNumber];
  trace ? console.log(ln + `el=${el.prefix}`) : null;
  // delete from DOM
  document.getElementById(el.prefix).remove();
  // delete from tasks.model.data
  model.data.splice(stepNumber, 1);
  tasks.model.renumber();
};

tasks.model.insertStep = (stepNumber = 0) => {
  stepNumber = parseInt(stepNumber);

  if (!stepNumber) {
    // якщо попередній крок не вказано, то додаємо в кінець масиву
    stepNumber = tasks.model.data.length;
  }

  let trace = 1,
    ln = `tasks.model.insertStep(after N${stepNumber})::`;
  trace ? console.log(ln + `Started!`) : null;

  let model = tasks.model;

  // визначаємо тип кроку
  let stepType = undefined;
  let stepTypes = Object.keys(tasks.reg.regs);
  if (stepTypes.length <= 2) {
    // під номером [0] йде опис програми, тому якщо в stepTypes тільки 2 елементи
    // то у нас тільки один тип кроку, беремо його
    stepType = stepTypes[1];
  } else {
    // більше одного типу кроків, окно вибору
    // TODO Доробити цей варіант з модальним окном
    tasks.modalWindow.setHeader(
      {
        ua: `Виберіть тип кроку`,
        en: `Select step type`,
        ru: `Выберите тип шага`,
      }[lang]
    );
    tasks.modalWindow.window.show();
  }
  trace ? console.log(ln + `New stepType=${stepType}`) : null;

  // крок після якого додавати новий
  let previousStep = document.getElementById(model.data[stepNumber].prefix);

  let el = tasks.createStep({
    stepNumber: 99,
    id: stepType,
    //container: hiddenStep,
    previousStep: previousStep,
  });

  if (trace) {
    console.log(ln + `previousStep=`);
    console.dir(previousStep);
  }

  // додаємо крок в model.data
  model.data.splice(stepNumber + 1, 0, el);
  // перенумеровуємо список
  model.renumber();
  // видаляємо вміст прихованого поля
};

/** Функція проходить по всім елементам tasks.model.data
 * та повертає значення регістрів та записує їх до масиву tasks.list
 * повертає масив з даними
 */

tasks.model.getValues = () => {
  let modelData = tasks.model.data;
  let data = [];
  for (let i = 0; i < modelData.length; i++) {
    data.push(modelData[i].getValues());
  }
  tasks.list = data;
  return data;
};

/** 2024-02-07 поки не використовується, та й чи потрібні взагалі?*/
tasks.model.moveUp = (stepNumber = undefined) => {
  // stepNumber = parseInt(stepNumber);
  // if (!stepNumber || stepNumber < 2) {
  //   throw new Error(`Uncompatible stepNumber=${stepNumber} ! `);
  //   return;
  // }
  // let trace = 1,
  //   ln = `tasks.model.moveUp(${stepNumber})::`;
  // trace ? console.log(ln + `Started!`) : null;
};

tasks.model.moveDown = (stepNumber = undefined) => {
  // stepNumber = parseInt(stepNumber);
  // if (!stepNumber || stepNumber > tasks.model.data.length - 1) {
  //   throw new Error(`Uncompatible stepNumber=${stepNumber} ! `);
  // }
  // let trace = 1,
  //   ln = `tasks.model.moveDown(${stepNumber})::`;
  // trace ? console.log(ln + `Started!`) : null;
};

tasks.createStep = (props = {}) => {
  let reg = tasks.reg.regs[props.id];
  let el;
  if (reg) {
    el = new tasks.ClassCreateStep({
      //editable: false, //tasks.reg.editable,
      model: tasks.model,
      stepNumber: props.stepNumber,
      reg: reg,
      container: props.container ? props.container : tasks.container,
      types: tasks.elementsTypes,
      previousStep: props.previousStep,
    });
    if (props.values) {
      el.setValues(props.values);
    }
  }
  return el;
};

tasks.renderList = function () {
  let trace = 1,
    ln = "tasks.renderList()::";

  // очищуємо модель
  tasks.model.data = [];

  // очищуємо контейнер
  this.container.innerHTML = "";

  // для скорочення коду
  let list = tasks.list;

  // ------- створюємо заголовок ----------
  let header = document.createElement("div");
  header.classList.add("row");
  let title = document.createElement("div");
  title.classList.add("col");
  title.innerHTML = `<h6>${tasks.header[lang]}</h6>`;
  header.appendChild(title);
  tasks.container.classList.add("border");
  this.container.appendChild(header);

  // if (list.length == 0) {
  //   // список програм пустий крок
  //   tasks.model.data.push(tasks.newStep("st1"));
  //   return;
  // } //if (list.length == 0)

  let i = 0;
  for (i = 0; i < list.length; i++) {
    let step = list[i];
    let props = {
      id: step.id,
      stepNumber: i,
      values: step,
    };
    let el = tasks.createStep(props);
    if (!el) {
      console.error(`Помилка створення кроку: ${JSON.stringify(props)}`);
      continue;
    }
    tasks.model.data.push(el);
    if (trace) {
      console.log(ln + `el=`);
      console.dir(el);
    }
  } //for
};
// -----------  element: select -------------------
beforeTrace = trace;
trace = 1;
/**
 * Створює та повертає елемент вибору
 *
 */
tasks.ClassCreateStep = class ClassCreateStep {
  /**
   * Створює контейнер з регістрами
   * @param {*} props
   * @property {DOMnode} props.container - DOM контенер в якому буде розміщено крок
   * @property {String} props.stepNumber - номер кроку в tasks.model.data "01","02:02"
   * @property {Object} props.reg - регістр, що містить в собі опис кроку
   * @property {Object} props.types - список доступних класів, що рендерять елементи
   * @property {Object} props.previousStep=undefined - елемент DOM після якого вставляти новий крок
   */

  constructor(props = {}) {
    this.ln = "ClassCreateStep(" + props.reg.id + ")::";

    let trace = 1,
      ln = this.ln + "Constructor()::";
    if (trace) {
      console.log(ln + `props=`);
      console.dir(props);
    }
    //
    if (!props.reg) {
      throw new Error(ln + "No item 'props.reg' defined");
    }
    this.reg = props.reg;
    // for testing this.reg.editable = false;
    // номер кроку
    if (!props.stepNumber && props.stepNumber != 0) {
      throw new Error(ln + "No item 'props.stepNumber' defined");
    }
    this.stepNumber = props.stepNumber;

    // створюємо унікальний префікс
    this.prefix = "id" + `${new Date().getTime().toString().slice(-6)}`;

    // this.types
    if (!props.types) {
      throw new Error(ln + "No item 'props.types' defined");
    }
    this.types = props.types;

    // this.model
    if (!props.model) {
      throw new Error(ln + "No item 'props.model' defined");
    }
    this.model = props.model;

    // створюємо контейнер для кроку
    {
      let row = document.createElement("div");
      row.classList.add("row");
      let col = document.createElement("div");
      col.classList.add("col");
      let main = document.createElement("div");
      main.classList.add("container-fluide");
      main.classList.add("border");
      main.classList.add("border-secondary");
      main.id = this.prefix;
      col.appendChild(main);
      row.appendChild(col);
      this.main = row;
      this.main.id = this.prefix;
    }

    // ------- додаємо контейнер в документ --------
    if (props.previousStep === undefined) {
      // попередній елемент не вказано,
      if (!props.container) {
        // контейнер не вказано - Помилка
        throw new Error(ln + "No props.container defined");
        return;
      } else {
        //додаємо крок в кінець контейнера
        props.container.appendChild(this.main);
      }
    } else {
      // вставляємо крок після попереднього елементу
      props.previousStep.after(this.main);
    }

    //  створюємо заголовок

    {
      let trace = 1;
      let header = document.createElement("div");
      header.classList.add("row");

      // номер кроку
      let numberCol = document.createElement("div");
      numberCol.classList.add("col-md-auto");
      this.numberField = document.createElement("span");
      this.numberField.classList.add("h5");
      this.renumber(this.stepNumber);
      numberCol.appendChild(this.numberField);
      header.appendChild(numberCol);

      // тип кроку
      let headerCol = document.createElement("div");
      headerCol.classList.add("col");
      let headerTitle = document.createElement("span");
      headerTitle.classList.add("h5");
      headerTitle.innerHTML = this.reg.header[lang];
      headerCol.appendChild(headerTitle);
      header.appendChild(headerCol);

      if (this.reg.editable) {
        header.appendChild(this.buttonsEditCreate());
      }

      // if (trace) {
      //   console.log(ln + `Type "regsList" was found. Created header=`);
      //   console.dir(header);
      // }

      this.main.appendChild(header);
    }

    // створюємо рядок, в якому буде розташовуватися вміст кроку
    let row = document.createElement("div");
    row.classList.add("row");
    row.id = this.prefix + "_row";
    this.main.appendChild(row);
    this.container = row;

    // рендеримо дітей
    this.children = new tasks.ClassRegsList({
      prefix: this.prefix,
      container: this.container,
      //parent: this,
      regs: this.reg.regs,
      types: this.types,
    });
    // console.log("------ getValues -------");
    // console.log(this.children.getValues());

    if (trace) {
      console.log(ln + `this=${""}`);
      console.dir(this);
    }
  }

  renumber(newNumber) {
    this.stepNumber = newNumber;
    this.numberField.innerHTML = "№ " + ("00" + this.stepNumber).slice(-2);
  }

  /**
   * Створює та повертає группу кнопок редагування
   */
  buttonsEditCreate() {
    // ---------- кнопки керування --------------------

    let buttonGroupe = document.createElement("div");
    buttonGroupe.classList.add("col-md-auto");
    buttonGroupe.classList.add("btn-group");
    buttonGroupe.setAttribute("role", "group");
    buttonGroupe.setAttribute("aria-label", "edit buttons");
    buttonGroupe.setAttribute("data-parent", this.prefix);

    /** Функція створює стандартну кнопку DOM та повертає її
     * @param {Object} props - список налаштувань
     * @property {Object} props.this - посилання на поточний об'єкт кроку
     * @property {String} props.style - стиль кнопки, наприклад "btn-info"
     * @property {Object} props.title - спливаюча підказка { ua:`` , en: ``, ru: `` };
     * @property {String} props.innerHTML - внутрішній код
     * @property {function} props.onclick - подія натискання
     * @returns {DOM-element} - DOM елемент кнопки
     */

    let createButton = (props = {}) => {
      let but = document.createElement("button");
      but.classList.add("btn");
      but.classList.add(props.style ? props.style : "btn-secondary");
      but.id =
        props.this.prefix +
        (props.name
          ? props.name
          : "noNameButton" + new Date().getTime().toString().slice(-7));
      but.setAttribute(
        "title",
        props.title
          ? props.title[lang]
          : {
              ua: `Немає опису`,
              en: `Undefined description`,
              ru: `Нет описания`,
            }[lang]
      );
      but.innerHTML = props.innerHTML ? props.innerHTML : "<h6>???</h6>";

      // but.onclick = props.onclick ? props.onclick.bind(this) : undefined;
      but.onclick = props.this.button_onclick
        ? props.this.button_onclick.bind(props.this)
        : undefined;
      return but;
    };

    // // -- buttom UP
    // let but_up = createButton({
    //   style: "btn-secondary",
    //   name: "_up",
    //   title: { ua: `Вище`, en: `Move up`, ru: `Вверх` },
    //   innerHTML: "<h6>&#9650;</h6>",
    //   this: this,
    // });
    // buttonGroupe.appendChild(but_up);

    // // -- buttom DOWN

    // let but_down = createButton({
    //   style: "btn-secondary",
    //   name: "_down",
    //   title: { ua: `Нижче`, en: `Move down`, ru: `Вниз` },
    //   innerHTML: "<h6>&#9660;</h6>",
    //   this: this,
    // });

    // buttonGroupe.appendChild(but_down);

    // -- buttom insert
    let but_insert = createButton({
      style: "btn-primary",
      name: "_insert",
      title: { ua: `Додати крок`, en: `Add step`, ru: `Добавить шаг` },
      innerHTML: "<h6>+</h6>",
      this: this,
    });
    buttonGroupe.appendChild(but_insert);

    // -- buttom DELETE
    let but_del = createButton({
      style: "btn-danger",
      name: "_del",
      title: { ua: `Видалити`, en: `Delete`, ru: `Удалить` },
      innerHTML: "<h6>X</h6>",
      this: this,
    });

    buttonGroupe.appendChild(but_del);
    return buttonGroupe;
  }

  button_onclick(ev) {
    let target = ev.target;
    //
    if (!target.id) {
      target = target.parentNode;
    }

    let id = target.id;

    let trace = 1,
      ln = this.ln + `button_onclick()::`; //
    trace
      ? console.log(ln + `Was pressed button [${id ? id : target.tagName}]!`)
      : null;
    let action = id.split("_").slice(-1)[0];
    trace ? console.log(ln + `Action is [${action}]!`) : null;
    //console.dir(target);
    switch (action) {
      case "del":
        this.model.deleteStep(this.stepNumber);
        break;
      case "up":
        this.model.moveUp(this.stepNumber);
        break;
      case "down":
        this.model.moveDown(this.stepNumber);
        break;
      case "insert":
        this.model.insertStep(this.stepNumber);
        break;
      default:
        console.error(ln + `Action "${action}" not finded!`);
        break;
    }
  }
  // onchange(event) {}
  getValues() {
    let res = {};
    res["id"] = this.reg.id;
    return Object.assign(res, this.children.getValues());
  }

  setValues(values) {
    let trace = 1,
      ln = this.ln + `setValues()::`;
    trace ? console.log(ln + `Started`) : null;
    for (let key in values) {
      if (values.hasOwnProperty(key)) {
        trace ? console.log(ln + `for(key=${key})=${values[key]}`) : null;
        this.children.setRegister(key, values[key]);
      } // if (value.hasOwnProperty(key))
    } //for
  }
}; // ClassCreateStep

trace = beforeTrace;
</script><script>//- запускаємо відображення списку кроків програми
tasks.renderList();

</script><div class="row"><div class="col"><button class="btn btn-primary" type="button" id="buttonTasksAccept">undefined</button></div></div><script>buttonTasksAccept.onclick = (e) => {
  //let el = document.createElement("pre");
  let data = tasks.model.getValues();
  //el.innerText = JSON.stringify(data);
  console.log("buttonTasksAccept.onclick");
  console.dir(data);
  // tasks.container.appendChild(el);
};
</script></div></div></div></div><script src="/bootstrap/bootstrap.min.js"></script></body></html>