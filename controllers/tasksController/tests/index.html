<!DOCTYPE html><html class="h-100"><head><title>pageTitle: not defined</title><link rel="stylesheet" href="/stylesheets/style.css"><link rel="stylesheet" href="/bootstrap/bootstrap.min.css"><script src="/bootstrap/bootstrap.bundle.min.js"> </script><script>function getDate() {
  var date = new Date().toLocaleString();
  let arr = date.split(",");
  date = arr[0] + "<br>" + arr[1];

  document.getElementById("timedisplay").innerHTML = date.toLocaleString();
}
setInterval(getDate, 0);
</script><script>var pageProps={};</script></head><body class="h-100"><div class="container-fluid h-100 d-flex flex-column"> <div class="row"><div class="col-3"><img src="/img/logo_bortek.png" alt="Бортек" id="logo"></div><div class="col my-auto mx-auto "><div class="h2 " id="pageTitle">pageTitle: not defined</div></div><div class="col-1 my-auto mx-auto "><div class="h5" id="timedisplay"></div></div><hr></div><div class="row h-100"><div class="col"><div class="h-100" id="pageBody"><p>--------------------- debugging info manager = -----------------------------<pre>{&quot;id&quot;:&quot;TasksManager&quot;,&quot;ln&quot;:&quot;ClassTasksManager(TasksManager)::&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;Створення програми&quot;,&quot;en&quot;:&quot;Program creating&quot;,&quot;ru&quot;:&quot;Создание программы&quot;},&quot;type&quot;:&quot;select&quot;,&quot;value&quot;:&quot;empty&quot;,&quot;comment&quot;:{&quot;ua&quot;:&quot;Після редагування програми натисніть кнопку [Застосувати]&quot;,&quot;en&quot;:&quot;After program creation, push [Accept] button&quot;,&quot;ru&quot;:&quot;После редактирования програмы, нажмите кнопку [Применить] &quot;},&quot;editable&quot;:true,&quot;regs&quot;:{},&quot;reg&quot;:{&quot;id&quot;:&quot;taskType&quot;,&quot;ln&quot;:&quot;ClassReg_select(taskType)::&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;Тип кроку&quot;,&quot;en&quot;:&quot;Select type of step&quot;,&quot;ru&quot;:&quot;Тип шага&quot;},&quot;type&quot;:&quot;select&quot;,&quot;comment&quot;:{&quot;ua&quot;:&quot;Доступні типи&quot;,&quot;en&quot;:&quot;Avaliable types&quot;,&quot;ru&quot;:&quot;Доступные типы&quot;},&quot;editable&quot;:true,&quot;regs&quot;:{&quot;empty&quot;:{&quot;id&quot;:&quot;empty&quot;,&quot;ln&quot;:&quot;Class_Task_general()::&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;Пусто&quot;,&quot;en&quot;:&quot;Empty&quot;,&quot;ru&quot;:&quot;Пусто&quot;},&quot;type&quot;:&quot;regsList&quot;,&quot;comment&quot;:{&quot;ua&quot;:&quot;Тип кроку не вказано&quot;,&quot;en&quot;:&quot;Type of the Step not defined&quot;,&quot;ru&quot;:&quot;Тип шага не указан&quot;},&quot;editable&quot;:true,&quot;regs&quot;:{}},&quot;ClassTask_Heating&quot;:{&quot;id&quot;:&quot;ClassTask_Heating&quot;,&quot;ln&quot;:&quot;ClassTaskThermal()::&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;Нагрівання&quot;,&quot;en&quot;:&quot;Heating&quot;,&quot;ru&quot;:&quot;Нагревание&quot;},&quot;type&quot;:&quot;regsList&quot;,&quot;comment&quot;:{&quot;ua&quot;:&quot;Немає опису&quot;,&quot;en&quot;:&quot;Note not defined&quot;,&quot;ru&quot;:&quot;Описания нет&quot;},&quot;editable&quot;:true,&quot;regs&quot;:{&quot;tT&quot;:{&quot;id&quot;:&quot;tT&quot;,&quot;ln&quot;:&quot;ClassReg_number(tT)::&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;T,°C&quot;,&quot;en&quot;:&quot;T,°C&quot;,&quot;ru&quot;:&quot;T,°C&quot;},&quot;type&quot;:&quot;number&quot;,&quot;value&quot;:0,&quot;comment&quot;:{&quot;ua&quot;:&quot;Цільова температура&quot;,&quot;en&quot;:&quot;Task temperature&quot;,&quot;ru&quot;:&quot;Целевая температура&quot;},&quot;editable&quot;:true,&quot;min&quot;:0,&quot;max&quot;:150},&quot;errTmin&quot;:{&quot;id&quot;:&quot;errTmin&quot;,&quot;ln&quot;:&quot;ClassReg_number(errTmin)::&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;errTmin,°C&quot;,&quot;en&quot;:&quot;errTmin,°C&quot;,&quot;ru&quot;:&quot;errTmin,°C&quot;},&quot;type&quot;:&quot;number&quot;,&quot;value&quot;:0,&quot;comment&quot;:{&quot;ua&quot;:&quot;Макс. відх. вниз (0=вимкн)&quot;,&quot;en&quot;:&quot;Limit of low temperature (0=disable)&quot;,&quot;ru&quot;:&quot;Макс. откл. вниз (0=выкл)&quot;},&quot;editable&quot;:true,&quot;min&quot;:-100,&quot;max&quot;:0},&quot;errTmax&quot;:{&quot;id&quot;:&quot;errTmax&quot;,&quot;ln&quot;:&quot;ClassReg_number(errTmax)::&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;errTmax,°C&quot;,&quot;en&quot;:&quot;errTmax,°C&quot;,&quot;ru&quot;:&quot;errTmax,°C&quot;},&quot;type&quot;:&quot;number&quot;,&quot;value&quot;:0,&quot;comment&quot;:{&quot;ua&quot;:&quot;Макс. відх. вверх (0=вимкн)&quot;,&quot;en&quot;:&quot;Limit of high temperature (0=disable)&quot;,&quot;ru&quot;:&quot;Макс. откл. вверх (0=выкл)&quot;},&quot;editable&quot;:true,&quot;min&quot;:0,&quot;max&quot;:100},&quot;regMode&quot;:{&quot;id&quot;:&quot;regMode&quot;,&quot;ln&quot;:&quot;ClassReg_select(regMode)::&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;Регулювання&quot;,&quot;en&quot;:&quot;Regulation&quot;,&quot;ru&quot;:&quot;Регулирование&quot;},&quot;type&quot;:&quot;select&quot;,&quot;value&quot;:&quot;pid&quot;,&quot;comment&quot;:{&quot;ua&quot;:&quot;Закон регулювання&quot;,&quot;en&quot;:&quot;Control type&quot;,&quot;ru&quot;:&quot;Закон регулирования&quot;},&quot;editable&quot;:true,&quot;regs&quot;:{&quot;pos&quot;:{&quot;id&quot;:&quot;pos&quot;,&quot;ln&quot;:&quot;ClassReg_regsList(pos)::&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;Позиційний&quot;,&quot;en&quot;:&quot;Positional&quot;,&quot;ru&quot;:&quot;Позиционный&quot;},&quot;type&quot;:&quot;regsList&quot;,&quot;comment&quot;:{&quot;ua&quot;:&quot;Позиційний закон регулювання&quot;,&quot;en&quot;:&quot;Positional regulation&quot;,&quot;ru&quot;:&quot;Позиционный закон регуллирования&quot;},&quot;editable&quot;:true,&quot;regs&quot;:{&quot;o&quot;:{&quot;id&quot;:&quot;o&quot;,&quot;ln&quot;:&quot;ClassReg_number(o)::&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;Неузгодження&quot;,&quot;en&quot;:&quot;Difference&quot;,&quot;ru&quot;:&quot;Рассогласование&quot;},&quot;type&quot;:&quot;number&quot;,&quot;value&quot;:-2,&quot;comment&quot;:{&quot;ua&quot;:&quot;Неузгодження температур,°С&quot;,&quot;en&quot;:&quot;Temperature difference,°С&quot;,&quot;ru&quot;:&quot;Рассогласование температур,°С&quot;},&quot;editable&quot;:true,&quot;min&quot;:-20,&quot;max&quot;:0}}},&quot;pid&quot;:{&quot;id&quot;:&quot;pid&quot;,&quot;ln&quot;:&quot;ClassReg_regsList(pid)::&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;ПІД&quot;,&quot;en&quot;:&quot;PID&quot;,&quot;ru&quot;:&quot;ПИД&quot;},&quot;type&quot;:&quot;regsList&quot;,&quot;comment&quot;:{&quot;ua&quot;:&quot;ПІД закон регулювання&quot;,&quot;en&quot;:&quot;PID regulation&quot;,&quot;ru&quot;:&quot;ПИД закон регуллирования&quot;},&quot;editable&quot;:true,&quot;regs&quot;:{&quot;o&quot;:{&quot;id&quot;:&quot;o&quot;,&quot;ln&quot;:&quot;ClassReg_number(o)::&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;П&quot;,&quot;en&quot;:&quot;P&quot;,&quot;ru&quot;:&quot;П&quot;},&quot;type&quot;:&quot;number&quot;,&quot;value&quot;:5,&quot;comment&quot;:{&quot;ua&quot;:&quot;Пропорційна складова&quot;,&quot;en&quot;:&quot;Proportional gain&quot;,&quot;ru&quot;:&quot;Пропорциональная составляющая&quot;},&quot;editable&quot;:true,&quot;min&quot;:0,&quot;max&quot;:100},&quot;ti&quot;:{&quot;id&quot;:&quot;ti&quot;,&quot;ln&quot;:&quot;ClassReg_number(ti)::&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;І&quot;,&quot;en&quot;:&quot;I&quot;,&quot;ru&quot;:&quot;И&quot;},&quot;type&quot;:&quot;number&quot;,&quot;value&quot;:5,&quot;comment&quot;:{&quot;ua&quot;:&quot;Інтегральна складова&quot;,&quot;en&quot;:&quot;Integral gain&quot;,&quot;ru&quot;:&quot;Интегральная составляющая&quot;},&quot;editable&quot;:true,&quot;min&quot;:0,&quot;max&quot;:100},&quot;td&quot;:{&quot;id&quot;:&quot;td&quot;,&quot;ln&quot;:&quot;ClassReg_number(td)::&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;Д&quot;,&quot;en&quot;:&quot;D&quot;,&quot;ru&quot;:&quot;Д&quot;},&quot;type&quot;:&quot;number&quot;,&quot;value&quot;:5,&quot;comment&quot;:{&quot;ua&quot;:&quot;Диференційна складова&quot;,&quot;en&quot;:&quot;Differencial gain&quot;,&quot;ru&quot;:&quot;Диферинциальная составляющая&quot;},&quot;editable&quot;:true,&quot;min&quot;:0,&quot;max&quot;:100}}}}},&quot;wT&quot;:{&quot;id&quot;:&quot;wT&quot;,&quot;ln&quot;:&quot;ClassReg_number(wT)::&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;wT,°C&quot;,&quot;en&quot;:&quot;wT,°C&quot;,&quot;ru&quot;:&quot;wT,°C&quot;},&quot;type&quot;:&quot;number&quot;,&quot;value&quot;:0,&quot;comment&quot;:{&quot;ua&quot;:&quot;Початок ПІД рег. (=0 вимкн.)&quot;,&quot;en&quot;:&quot;Start PID regulation (=0 off)&quot;,&quot;ru&quot;:&quot;Начало ПИД рег. (=0-выкл.)&quot;},&quot;editable&quot;:true,&quot;min&quot;:-200,&quot;max&quot;:0},&quot;H&quot;:{&quot;id&quot;:&quot;H&quot;,&quot;ln&quot;:&quot;ClassReg_timer(H)::&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;Нагрівання&quot;,&quot;en&quot;:&quot;Heating&quot;,&quot;ru&quot;:&quot;Нагревание&quot;},&quot;type&quot;:&quot;timer&quot;,&quot;value&quot;:0,&quot;comment&quot;:{&quot;ua&quot;:&quot;Час нагрівання (=0 - макс. швидко)&quot;,&quot;en&quot;:&quot;Heating time (=0 quick)&quot;,&quot;ru&quot;:&quot;Время нагревания (=0 макс. быстро)&quot;},&quot;editable&quot;:true,&quot;min&quot;:0,&quot;max&quot;:1439}}}}},&quot;list&quot;:[{&quot;id&quot;:&quot;caption&quot;,&quot;header&quot;:{&quot;ua&quot;:&quot;&quot;,&quot;en&quot;:&quot;&quot;,&quot;ru&quot;:&quot;&quot;},&quot;note&quot;:&quot;&quot;},{&quot;id&quot;:&quot;ClassTask_Heating&quot;,&quot;tT&quot;:500,&quot;errTmin&quot;:-15,&quot;errTmax&quot;:15,&quot;regMode&quot;:&quot;pid&quot;,&quot;o&quot;:10,&quot;i&quot;:10,&quot;d&quot;:10},{&quot;id&quot;:&quot;TaskNitriding&quot;,&quot;kN&quot;:1.2,&quot;regMode&quot;:&quot;pid&quot;,&quot;o&quot;:10,&quot;i&quot;:10,&quot;d&quot;:10}]}  </pre></p><p>--------------------- debugging info -----------------------------</p><div class="row"><div class="col"><h3>Завдання</h3></div></div><div class="row"><div class="col" id="tasksContainer"></div></div><script>const lang= 'ua'; 
const tasks={};
tasks.header = JSON.parse(  '{"ua":"Створення програми","en":"Program creating","ru":"Создание программы"}' );
tasks.comment = JSON.parse(  '{"ua":"Після редагування програми натисніть кнопку [Застосувати]","en":"After program creation, push [Accept] button","ru":"После редактирования програмы, нажмите кнопку [Применить] "}' );
tasks.id=JSON.parse(  '"TasksManager"' );
tasks.reg = JSON.parse(  '{"id":"taskType","ln":"ClassReg_select(taskType)::","header":{"ua":"Тип кроку","en":"Select type of step","ru":"Тип шага"},"type":"select","comment":{"ua":"Доступні типи","en":"Avaliable types","ru":"Доступные типы"},"editable":true,"regs":{"empty":{"id":"empty","ln":"Class_Task_general()::","header":{"ua":"Пусто","en":"Empty","ru":"Пусто"},"type":"regsList","comment":{"ua":"Тип кроку не вказано","en":"Type of the Step not defined","ru":"Тип шага не указан"},"editable":true,"regs":{}},"ClassTask_Heating":{"id":"ClassTask_Heating","ln":"ClassTaskThermal()::","header":{"ua":"Нагрівання","en":"Heating","ru":"Нагревание"},"type":"regsList","comment":{"ua":"Немає опису","en":"Note not defined","ru":"Описания нет"},"editable":true,"regs":{"tT":{"id":"tT","ln":"ClassReg_number(tT)::","header":{"ua":"T,°C","en":"T,°C","ru":"T,°C"},"type":"number","value":0,"comment":{"ua":"Цільова температура","en":"Task temperature","ru":"Целевая температура"},"editable":true,"min":0,"max":150},"errTmin":{"id":"errTmin","ln":"ClassReg_number(errTmin)::","header":{"ua":"errTmin,°C","en":"errTmin,°C","ru":"errTmin,°C"},"type":"number","value":0,"comment":{"ua":"Макс. відх. вниз (0=вимкн)","en":"Limit of low temperature (0=disable)","ru":"Макс. откл. вниз (0=выкл)"},"editable":true,"min":-100,"max":0},"errTmax":{"id":"errTmax","ln":"ClassReg_number(errTmax)::","header":{"ua":"errTmax,°C","en":"errTmax,°C","ru":"errTmax,°C"},"type":"number","value":0,"comment":{"ua":"Макс. відх. вверх (0=вимкн)","en":"Limit of high temperature (0=disable)","ru":"Макс. откл. вверх (0=выкл)"},"editable":true,"min":0,"max":100},"regMode":{"id":"regMode","ln":"ClassReg_select(regMode)::","header":{"ua":"Регулювання","en":"Regulation","ru":"Регулирование"},"type":"select","value":"pid","comment":{"ua":"Закон регулювання","en":"Control type","ru":"Закон регулирования"},"editable":true,"regs":{"pos":{"id":"pos","ln":"ClassReg_regsList(pos)::","header":{"ua":"Позиційний","en":"Positional","ru":"Позиционный"},"type":"regsList","comment":{"ua":"Позиційний закон регулювання","en":"Positional regulation","ru":"Позиционный закон регуллирования"},"editable":true,"regs":{"o":{"id":"o","ln":"ClassReg_number(o)::","header":{"ua":"Неузгодження","en":"Difference","ru":"Рассогласование"},"type":"number","value":-2,"comment":{"ua":"Неузгодження температур,°С","en":"Temperature difference,°С","ru":"Рассогласование температур,°С"},"editable":true,"min":-20,"max":0}}},"pid":{"id":"pid","ln":"ClassReg_regsList(pid)::","header":{"ua":"ПІД","en":"PID","ru":"ПИД"},"type":"regsList","comment":{"ua":"ПІД закон регулювання","en":"PID regulation","ru":"ПИД закон регуллирования"},"editable":true,"regs":{"o":{"id":"o","ln":"ClassReg_number(o)::","header":{"ua":"П","en":"P","ru":"П"},"type":"number","value":5,"comment":{"ua":"Пропорційна складова","en":"Proportional gain","ru":"Пропорциональная составляющая"},"editable":true,"min":0,"max":100},"ti":{"id":"ti","ln":"ClassReg_number(ti)::","header":{"ua":"І","en":"I","ru":"И"},"type":"number","value":5,"comment":{"ua":"Інтегральна складова","en":"Integral gain","ru":"Интегральная составляющая"},"editable":true,"min":0,"max":100},"td":{"id":"td","ln":"ClassReg_number(td)::","header":{"ua":"Д","en":"D","ru":"Д"},"type":"number","value":5,"comment":{"ua":"Диференційна складова","en":"Differencial gain","ru":"Диферинциальная составляющая"},"editable":true,"min":0,"max":100}}}}},"wT":{"id":"wT","ln":"ClassReg_number(wT)::","header":{"ua":"wT,°C","en":"wT,°C","ru":"wT,°C"},"type":"number","value":0,"comment":{"ua":"Початок ПІД рег. (=0 вимкн.)","en":"Start PID regulation (=0 off)","ru":"Начало ПИД рег. (=0-выкл.)"},"editable":true,"min":-200,"max":0},"H":{"id":"H","ln":"ClassReg_timer(H)::","header":{"ua":"Нагрівання","en":"Heating","ru":"Нагревание"},"type":"timer","value":0,"comment":{"ua":"Час нагрівання (=0 - макс. швидко)","en":"Heating time (=0 quick)","ru":"Время нагревания (=0 макс. быстро)"},"editable":true,"min":0,"max":1439}}}}}' );
tasks.type = "select"
tasks.list = JSON.parse(  '[{"id":"caption","header":{"ua":"","en":"","ru":""},"note":""},{"id":"ClassTask_Heating","tT":500,"errTmin":-15,"errTmax":15,"regMode":"pid","o":10,"i":10,"d":10},{"id":"TaskNitriding","kN":1.2,"regMode":"pid","o":10,"i":10,"d":10}]' );
tasks.container = document.getElementById( 'tasksContainer' );</script><script> // створюємо прапорці трасування, так як в нас багато файлів нам потрыбно в кожному
// з них вмикати трасування окремо від інших , тому кожний файл з кодом
// перед виконанням свого коду запамятовує поточне значення trace в beforeTrace: 'beforeTrace=trace'
// після завершення відновлює попереднє значення 'trace=beforeTrace', таким чином модулі не будуть заважати іншим
let trace = 1,
  beforeTrace = 0;

/**
 * Створює рядка кроку програми
 * @param {Array} list
 *
 */
tasks.newStep = (prefix) => {
  let trace = 1,
    ln = `tasks.newStep(${prefix})::`;
  trace ? console.log(ln + `Started!`) : null;
  let el = new tasks.createStep({
    prefix: prefix,
    reg: tasks.reg,
    container: tasks.container,
    types: tasks.elementsTypes,
  });
  if (trace) {
    console.log(ln + `el=`);
    console.dir(el);
  }
  return el;
};

tasks.renderList = function () {
  let list = tasks.list;
  let trace = 1,
    ln = "tasks.renderList()::";

  // ------- створюємо заголовок ----------
  let header = document.createElement("div");
  header.classList.add("row");
  let title = document.createElement("div");
  title.classList.add("col");
  title.innerHTML = `<h6>${tasks.header[lang]}</h6>`;
  header.appendChild(title);
  tasks.container.classList = "border";
  this.container.appendChild(header);
  //

  tasks.model = [];

  if (list.length == 0) {
    // список програм пустий крок
    tasks.model.push(tasks.newStep("st1"));
    return;
  } //if (list.length == 0)
  let i = 1;
  for (i = 1; i < list.length; i++) {
    let step = list[i];
    let reg = tasks.reg.regs[step.id];
    // trace ? console.log(ln + `reg=${JSON.stringify(reg)}`) : null;
    if (reg) {
      let el = new this.createStep({
        prefix: `st${i + 1}`,
        reg: reg,
        container: tasks.container,
        types: tasks.elementsTypes,
      });
      el.setValues(step);
      tasks.model.push(el);
      if (trace) {
        console.log(ln + `el=`);
        console.dir(el);
      }
    }
    //tasks.model = el;
  } //for
  i += 1;
  if (tasks.reg.editable || list.length === 0) {
    tasks.model.push(tasks.newStep(`st${("0" + i).slice(-2)}`));
    return;
  }
};

/** список доступних класів типів регістрів,
 * що створюють відповідні елементи
 * {select:ClassElementSelect, number:ClassElementNumber, ...}
 */
tasks.elementsTypes = {};

//tasks.ClassCreateElement = ClassCreateElement;
class ClassCreateElement {
  /**
   * Створює налаштований DOM-елемент загального типу
   * @param {Object} props
   * @property {string} props.prefix - префікс для id елементу
   * @property {string} props.tag - тип елементу (number, range, select)
   * @property {Object} props.reg  - типовий регістр
   * @property {Object} props.container - контейнер в якому потрібно розмістити елемент
   */
  constructor(props = {}) {
    this.ln = "ClassCreateElement()::";
    let trace = 1,
      ln = this.ln + "constructror()::";
    trace ? console.log(ln + "props=") : null;
    trace ? console.dir(props) : null;
    // -- батьківський контейнер для елементу -----
    if (!props.container) {
      console.error(ln + "Не вказано батьківський контейнер!!!");
    } else {
      this.container = props.container;
    }
    // -- тег основного елемента, щоб створити шаблон
    this.tag = props.tag;
    // -- префікс -----
    this.prefix = props.prefix;
    // -- id -----
    this.id = props.reg.id;
    // -- регістр
    this.reg = props.reg;
    // тип регистру
    this.type = props.reg.type;

    // дозвіл на зміну значення
    this.readonly = props.reg.readonly;

    this.value = props.reg.value;
    this.beforeValue = props.reg.value;
    // -- id - елементу DOM
    this.elId = this.getElId();
    // контейнер для всього елементу
    this.div = document.createElement("div");
    this.div.id = this.getElId();
    this.div.classList.add("col");
    this.div.classList.add("form-group");
    // ---- <label=header> --------
    this.label = document.createElement("label");
    this.label.setAttribute("for", this.id);
    this.label.classList.add("h6");
    this.label.innerHTML = this.reg.header[lang];
    // ---- <comment> --------
    this.comment = document.createElement("small");
    this.comment.innerHTML = this.reg.comment[lang];
    // ---- Field --------
    this.field = document.createElement(this.tag);
    this.field.classList.add("form-control");
    this.field.classList.add(this.prefix);
    this.field.classList.add("field");
    this.field.id = this.elId + "_field";
    if (this.readonly) {
      this.field.classList.add("readonly");
    }
    this.div.appendChild(this.label);
    this.div.appendChild(this.field);
    this.div.appendChild(this.comment);
    // -- поточне значення -----
    if (props.reg.value | (props.reg.value === 0)) {
      this.value = props.reg.value;
      this.beforeValue = props.reg.value;
      this.setValue(this.value);
    }
    // додаємо в контейнер елемент
    this.container.appendChild(this.div);
    // привязуємо this до обробника до this
    this.field.onchange = this.onchange.bind(this);
  }

  onchange(event) {
    let ln = this.ln + "onchange()::";
    if (trace) {
      console.log(ln + "this=");
      console.dir(this);
    }
    trace ? console.log(ln + "this.field.value=" + this.getFieldValue()) : null;
    //this.setValue(this.getFieldValue());
  }

  // створює ідентифікатор для елементу DOM
  getElId(id = null) {
    id = id === null ? this.id : id;
    return this.prefix + "__" + id; //два підкреслення (щоб легко відділяти id регістру)
  }

  setValue(val) {
    let trace = 0,
      ln = this.ln + `setValue(${val})::`;
    trace
      ? console.log(
          ln +
            `Started:this.beforeValue=${this.beforeValue};this.value=${this.value}`
        )
      : null;
    trace = 1;
    this.value = val;
    this.beforeValue = this.value;
    trace
      ? console.log(
          ln +
            `Finished:this.beforeValue=${this.beforeValue};this.value=${this.value}`
        )
      : null;
    this.field.value = val;
    this.reg.value = val;
  }

  setProperty(key, value) {
    console.log(this.ln + `setProperty[${key}]=${value}. Поки не реалізовано!`);
  }

  getBeforeValue() {
    return this.beforeValue;
  }

  /**
   * @return true якщо елемент змінився
   */

  hasChanged() {
    let trace = 1,
      ln = this.ln + "hasChanged()::";

    let res;
    res =
      this.beforeValue == undefined
        ? true
        : this.getFieldValue() != this.getBeforeValue();
    trace
      ? console.log(
          ln +
            `this.getBeforeValue()=${this.getBeforeValue()};this.getFieldValue()=${this.getFieldValue()}; res=${res}`
        )
      : null;
    return res;
  }

  getFieldValue() {
    return this.field.value;
  }
}
// -----------  element: select -------------------
beforeTrace = trace;
trace = 1;

/**
 * Створює елемент вибору select
 *
 */
class ClassElementSelect extends ClassCreateElement {
  constructor(props = {}) {
    props.tag = "select";
    super(props);
    this.ln = "ClassElementSelect(" + props.reg.id + ")::";
    let trace = 1,
      ln = this.ln + "Constructor()::";
    this.regs = this.reg.regs;

    // створюємо список <option>
    let keys = "";
    let first = true;
    for (let key in this.regs) {
      if (this.regs.hasOwnProperty(key)) {
        let trace = 1;
        let selected = "";
        // якщо this.value не вказано, то перший елемент в списку опцій обирається автоматично браузером
        if (!first & (keys == this.value)) {
          selected = "selected";
          //   // якщо це перша опція, вибираємо її як початкову
          //   this.setValue(field.value = key;
          //   this.field.dataset.beforeValue = key;
        }
        trace ? console.log(ln + "key=" + key) : null;
        keys += `<option value='${key}' ${selected}> ${this.reg.regs[key].header[lang]} </option>`;
      }
    } //for
    // -- опції вибору -------
    this.field.innerHTML = keys;
    // -- обробник зміни значення поля ----------
    this.field.onchange = this.onchange.bind(this);
    // -- початкова ініціалізація -----------
    this.value = this.getFieldValue();
    trace ? console.log(ln + `this.value=${this.value}`) : null;

    // create children
    this.children = new tasks.ClassRegsList({
      container: this.container,
      prefix: this.elId,
      regs: this.regs[this.value].regs,
      types: this.types,
    });

    this.setValue(this.value);

    if (trace) {
      console.log(ln + `this.getFieldValue()=${this.getFieldValue()}`);
      console.dir(this);
    }
  }

  onchange(event) {
    let ln = this.ln + "onchange()::elem_select()::";
    let trace = 1;
    if (!this.hasChanged()) {
      return;
    }
    // this.children.remove();
    // this.render(this.regs[this.getFieldValue()]);
    this.setValue(this.getFieldValue());
    super.onchange(event);
  }

  setValue(val) {
    let trace = 1,
      ln = this.ln + `setValue(${val})::`;
    trace ? console.log(ln + `Started`) : null;
    super.setValue(val);
    this.children.remove();
    this.children.render(this.regs[val].regs);
  }
}

tasks.elementsTypes["select"] = ClassElementSelect;

trace = beforeTrace;
// -----------  element: select -------------------
beforeTrace = trace;
trace = 1;
/**
 * Створює та повертає елемент вибору
 *
 */
class ClassElementNumber extends ClassCreateElement {
  constructor(props = {}) {
    props.tag = "input";
    super(props);
    this.ln = "ClassElementNumber(" + props.reg.id + ")::";
    let trace = 1,
      ln = this.ln + "Constructor()::";

    // -- тип поля Number -------
    this.field.setAttribute("type", "number");

    // -- обробник зміни значення поля ----------
    this.field.onchange = this.onchange.bind(this);

    if (props.reg.min | (props.reg.min === 0)) {
      this.field.setAttribute("min", props.reg.min);
      this.min = props.reg.min;
    }

    if (props.reg.max | (props.reg.max === 0)) {
      this.field.setAttribute("max", props.reg.max);
      this.max = props.reg.max;
    }

    this.field.setAttribute("value", props.reg.value);
    if (trace) {
      console.log(ln + "this=");
      console.dir(this);
    }
  }
  onchange(event) {
    let trace = 1,
      ln = this.ln + "onchange()::";
    super.onchange(event);
    let val = this.getFieldValue();
    this.setValue(val);
    //this.field.value = this.value;
  } // onchange()

  setValue(val) {
    if (val > this.max) {
      console.error(
        this.ln +
          `Can't set ${val}, because max=${this.max}. Was setted max value!`
      );
      val = this.max;
    }
    if (val < this.min) {
      val = this.min;
      console.error(
        this.ln +
          `Can't set ${val}, because min=${this.min}. Was setted min value!`
      );
    }
    super.setValue(val);
  }
} // class

tasks.elementsTypes["number"] = ClassElementNumber;

trace = beforeTrace;
// -----------  element: select -------------------
beforeTrace = trace;
trace = 1;

/**
 * Створює елемент для вводу часу
 *
 */

//

tasks.elementsTypes["timer"] = class ClassElementTimer extends (
  ClassCreateElement
) {
  constructor(props = {}) {
    props.tag = "input";
    super(props);
    this.ln = "ClassElementTimer(" + props.reg.id + ")::";
    let trace = 1,
      ln = this.ln + "Constructor()::";

    // -- тип поля  -------
    this.field.setAttribute("type", "time");

    // хв, мінімальне значення
    this.min = 0;
    if (props.reg.min || props.reg.min === 0) {
      this.min = props.reg.min;
    }
    this.field.setAttribute("min", this.minutesToString(this.min));

    // хв, максимальне значення
    this.max = 99 * 60; //99 годин
    if (props.reg.max | (props.reg.max === 0)) {
      this.max = props.reg.max;
    }
    this.field.setAttribute("max", this.minutesToString(this.max));

    // встановлюємо значення поля
    this.field.value = this.minutesToString(this.value);

    if (trace) {
      console.log(ln + "this=");
      console.dir(this);
    }
  }
  onchange(event) {
    let trace = 1,
      ln = this.ln + "onchange()::";
    super.onchange(event);
    let val = this.getFieldValue();
    this.setValue(this.stringToMinutes(val));
    //this.field.value = this.value;
  } // onchange()

  /**
   * Вираховує кількість хвилин в hhmm
   * @param {String} hhmm - час в форматі "00:00"
   */
  stringToMinutes(hhmm = "00:00") {
    let ln = this.ln + `stringToMinutes(${hhmm})::`;
    let arr = hhmm.split(":");
    if (arr.length > 2) {
      throw Error(ln + `Невірний формат аргументу`);
    }
    let val = parseInt(arr[0]) * 60 + parseInt(arr[1]);
    return val;
  }

  minutesToString(minutes) {
    let time = new Date(minutes * 60 * 1000).toISOString();
    //console.log(time);
    return time.slice(11, -8);
  }

  setValue(val) {
    if (val > this.max) {
      console.error(
        this.ln +
          `Can't set ${val}, because max=${this.max}. Was setted max value!`
      );
      val = this.max;
    }
    if (val < this.min) {
      val = this.min;
      console.error(
        this.ln +
          `Can't set ${val}, because min=${this.min}. Was setted min value!`
      );
    }
    super.setValue(val);
    this.field.value = this.minutesToString(val);
  }
}; // class

trace = beforeTrace;
// -----------  element: select -------------------
beforeTrace = trace;
trace = 1;
/**
 * Створює та повертає список об'єктів регістрів та їх DOM - елементи
 *
 */
tasks.ClassRegsList = class ClassRegsList {
  /**
   * Створює контейнер з регістрами
   * @param {*} props
   * @property {DOMnode} props.container - DOM контенер в якому буде розміщено
   * @property {String} props.prefix - префікс до id
   * @property {Object} props.regs - список регістрів
   * @property {Object} props.types - список доступних класів, що рендерять елементи
   */
  #type = "regsList";

  constructor(props = {}) {
    this.ln = `ClassRegsList(${props.prefix})::`;
    let trace = 1,
      ln = this.ln + "сonstructor()::";
    //
    if (trace) {
      console.log(ln + `props=`);
      console.dir(props);
    }
    // тип
    // this.type = "listRegs";
    // об'єкт, що містить в собі список доступних типів (класів) регістрів,
    // що використовуються для їх створення
    if (!props.types) {
      // TODO Виправити костиля. Ймовірно список типів
      // потріпно зберігати у властивостях класу  ClassRegsList.types
      // в цьому разі він буде завжди з цим класом
      props.types = tasks.elementsTypes;
      //throw new Error(ln + "'props.types' not defined !!");
    }
    this.types = props.types;

    // список регістрів
    if (!props.regs) {
      throw new Error(ln + "'props.regs' not defined !!");
      props.regs = {};
    }
    //this.regs = props.regs;

    // prefix
    this.prefix = props.prefix ? props.prefix : "undefined_";

    // контейнер DOM, в якому буде розміщено елемент
    if (!props.container) {
      throw new Error(
        ln + "'props.container' not defined !! Was selected 'document.body' "
      );
      props.container = document.body;
    }
    this.container = props.container;

    // список дітей, елементу

    this.children = {};

    // -- початкова ініціалізація -----------
    this.render(props.regs);

    if (trace) {
      console.log(ln + `Was created element. this=${""}`);
      console.dir(this);
    }
  }

  onchange(event) {}

  remove() {
    let trace = 1,
      ln = this.ln + `remove(${this.prefix})::`;
    let regs = this.children;
    for (let key in regs) {
      let lln = ln + `child[${key}]::`;
      trace ? console.log(ln + `key=${key}`) : null;
      if (regs.hasOwnProperty(key)) {
        let child = regs[key];
        document.getElementById(child.div.id).remove();
        trace
          ? console.log(
              lln + `Was removed element from DOM id= ${child.div.id} )`
            )
          : null;
        regs[key] = undefined;
      } //if (regs.hasOwnProperty(key))
    } //for
    this.children = {};
    console.log(ln + "Completed!");
  }

  render(regs) {
    let trace = 1,
      ln = this.ln + `render(${this.prefix})::`;
    trace ? console.log(ln + `Started`) : null;
    trace ? console.log(ln + `regs=${regs}`) : null;
    this.children = {};
    for (let key in regs) {
      trace ? console.log(ln + `key=${key}`) : null;
      if (regs.hasOwnProperty(key)) {
        let trace = 1;
        let item = regs[key];
        trace
          ? console.log(
              ln +
                `for (key=${key}) item.id= ${item.id}; item.type=${item.type} )`
            )
          : null;

        if (this.types[item.type]) {
          // тип регістру визначений, визиваємо його конструктор
          let el = new this.types[item.type]({
            prefix: this.prefix,
            reg: item,
            container: this.container,
          });
          // перевіряємо чи є елемент з таким id в DOM
          if (document.getElementById(el.idEl)) {
            throw Error(
              ln + `DOM element with id = ${el.idEl} already presented!!`
            );
          }
          // додаємо в дерево DOM
          this.container.appendChild(el.div);
          // запамятовуємо в списку дітей
          this.children[el.id] = el;
          trace
            ? console.log(ln + `Created element DOM id= ${el.elId} )`)
            : null;
        } //if
      } //if (regs.hasOwnProperty(key))
    } // for
    trace
      ? console.log(ln + `Created this.children=${Object.keys(this.children)}`)
      : null;
  } //renderRegs()

  /**
   * Збирає значення регістрів всіх дітей
   * @returns {Object} {reg1.id:reg1.value, reg2.id:reg2.value, } for example {'tT':500,'o':15,..}
   */
  getValues() {
    let trace = 0,
      ln = this.ln + ` getValues(${this.prefix})::`;
    let children = this.children;
    let res = {};
    for (let key in children) {
      if (children.hasOwnProperty(key)) {
        let lln = ln + `for (${key})::`,
          trace = 0;
        let child = children[key];
        if (trace) {
          console.log(lln + `child=`);
          console.dir(child);
        }
        res[child.id] = child.value;
        if (child.children) {
          let resChild = child.children.getValues();
          Object.assign(res, resChild);
        }
      }
    }
    //trace = 1;
    if (trace) {
      console.log(ln + `Response=`);
      console.dir(res);
    }
    return res;
  } //getValues()

  // /**
  //  *
  //  * @param {Object} values - {'tT':500,...} or {'tT':{value:500,enable:true,...},...}
  //  */
  // setValues(values) {
  //   let trace = 0,
  //     ln = this.ln + ` setValues(${this.prefix})::`;
  //   let children = this.children;

  //   for (let key in values) {
  //     if (values.hasOwnProperty(key)) {
  //       let el = values[key];
  //     } //if (regs.hasOwnProperty(key))
  //   } // for
  // } //setValues(values)

  setRegister(id, value) {
    let trace = 0,
      ln = this.ln + `setRegister(${id};${value})::`;
    trace ? console.log(ln + `Started`) : null;
    let reg = this.findRegister(id);
    if (reg) {
      // регістр знайдено
      if (typeof value != "object") {
        reg.setValue(value);
        return value;
      }
      // якщо value - об'экт зі значеннями, то перебираємо ці значення
      for (let key in value) {
        if (value.hasOwnProperty(key)) {
          if (reg[key]) {
            // поле key  в регістрі знайдено
            reg[key].setProperty(key, value[key]);
          }
        } //for
      }
    } // setRegister(id,values)
  }

  /**
   * Знаходить серед дітей регістр з вказаним id
   * @param {String} id
   * @return {undefined | Object }
   */
  findRegister(id) {
    let trace = 0,
      ln = this.ln + `findRegister(${id}})::`;
    trace ? console.log(ln + `Started`) : null;

    let res = this.children[id];

    if (!res) {
      // якщо при прямому пошуку не знайдено
      // шукаємо в регістрах з дітьми
      for (let key in this.children) {
        if (this.children.hasOwnProperty(key)) {
          if (this.children[key].children) {
            res = this.children[key].children.findRegister(id);
            if (res) {
              break;
            }
          }
        }
      } //for
    }
    return res;
  }
}; // Class

trace = beforeTrace;
// -----------  element: select -------------------
beforeTrace = trace;
trace = 1;
/**
 * Створює та повертає елемент вибору
 *
 */
tasks.createStep = class ClassCreateStep {
  /**
   * Створює контейнер з регістрами
   * @param {*} props
   * @property {DOMnode} props.container - DOM контенер в якому буде розміщено крок
   * @property {String} props.prefix - префікс до id елемента
   * @property {Object} props.reg - регістр, що містить в собі крок
   * @property {Object} props.types - список доступних класів, що рендерять елементи
   */

  constructor(props = {}) {
    this.ln = "ClassCreateStep(" + props.reg.id + ")::";

    let trace = 1,
      ln = this.ln + "Constructor()::";

    //
    if (!props.reg) {
      throw new Error(ln + "No item 'props.reg' defined");
    }
    this.reg = props.reg;
    // prefix
    if (!props.prefix) {
      throw new Error(ln + "No item 'props.prefix' defined");
    }
    this.prefix = props.prefix;

    // створюємо контейнер для кроку
    this.main = document.createElement("div");
    this.main.classList.add("container");
    this.main.classList.add("border");
    this.main.classList.add("border-secondary");
    if (!props.container) {
      throw new Error(ln + "No props.container defined");
    }
    props.container.appendChild(this.main);

    // якщо це список регістрів то створюємо заголовок
    if (this.reg.type == "regsList") {
      let trace = 1;
      let header = document.createElement("div");
      header.classList.add("row");
      let headerCol = document.createElement("div");
      headerCol.classList.add("col");
      let headerTitle = document.createElement("div");
      headerTitle.classList.add("h6");
      headerTitle.innerHTML = this.reg.header[lang];

      if (trace) {
        console.log(ln + `Type "regsList" was found. Created header=`);
        console.dir(header);
      }
      headerCol.appendChild(headerTitle);
      header.appendChild(headerCol);
      this.main.appendChild(header);
    }

    // створюємо рядок, в якому буде розташовуватися вміст
    let row = document.createElement("div");
    row.classList.add("row");
    row.id = props.prefix;
    this.main.appendChild(row);
    this.container = row;

    // рендеримо дітей
    this.children = new tasks.ClassRegsList({
      prefix: this.prefix,
      container: this.container,
      //parent: this,
      regs: this.reg.regs,
      types: props.types,
    });
    // console.log("------ getValues -------");
    // console.log(this.children.getValues());

    if (trace) {
      console.log(ln + `this=${""}`);
      console.dir(this);
    }
  }

  // onchange(event) {}
  getValues() {
    let res = {};
    res["id"] = this.reg.id;
    return Object.assign(res, this.children.getValues());
  }

  setValues(values) {
    let trace = 1,
      ln = this.ln + `setValues()::`;
    trace ? console.log(ln + `Started`) : null;
    for (let key in values) {
      if (values.hasOwnProperty(key)) {
        trace ? console.log(ln + `for(key=${key})=${values[key]}`) : null;
        this.children.setRegister(key, values[key]);
      } // if (value.hasOwnProperty(key))
    } //for
  }
}; // ClassCreateStep

trace = beforeTrace;
</script><script>//- запускаємо відображення списку кроків програми
tasks.renderList();

</script><div class="row"><div class="col"><button class="btn btn-primary" type="button" id="buttonTasksAccept">Застосувати</button></div></div><script>buttonTasksAccept.onclick = (e) => {
  let el = document.createElement("pre");
  let data = [];
  for (let i = 0; i < tasks.model.length; i++) {
    data.push(tasks.model[i].getValues());
  }
  el.innerText = JSON.stringify(data);
  tasks.container.appendChild(el);
};
</script></div></div></div></div><script src="/bootstrap/bootstrap.min.js"></script></body></html>